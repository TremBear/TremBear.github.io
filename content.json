{"meta":{"title":"TremBear's Blog","subtitle":"学习弯道超车的技巧!","description":"熊俊伟的博客","author":"trembear","url":"http://trembear.github.io","root":"/"},"pages":[{"title":"tags","date":"2019-06-19T09:56:05.000Z","updated":"2019-10-22T01:20:39.888Z","comments":false,"path":"tags/index.html","permalink":"http://trembear.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-06-19T09:56:50.000Z","updated":"2019-10-22T01:20:39.888Z","comments":false,"path":"categories/index.html","permalink":"http://trembear.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"多线程与锁","slug":"java/多线程和锁","date":"2019-11-15T09:18:07.000Z","updated":"2019-12-03T07:57:18.142Z","comments":true,"path":"2019/11/15/java/多线程和锁/","link":"","permalink":"http://trembear.github.io/2019/11/15/java/多线程和锁/","excerpt":"","text":"线程创建形式 继承ThreadLocal 实现Runnable 实现Callable：有返回值的任务，用Future接受返回值 使用线程池ExecutorService实现 newCachedThreadPool 不定长线程池 newFixedThreadPool 定长线程池 newScheduledThreadPool 定时线程池 newSingleThreadExecutor 串行线程池 sleep() 和 wait()Synchronized使用方法ThreadLocal通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。JDK中提供的ThreadLocal类正是为了解决这样的问题。 ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。 ThreadLocal 内存泄露问题:ThreadLocal,中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会key会被清理掉，而value不会被清理掉。在调用set()、get()、remove() 方法的时候，会清理掉key为null的记录。 乐观锁总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。 版本号机制每次修改一个数据，一般是在数据表中加上一个数据版本号version字段。操作示意如下： 数据库里有金额100，version=1 A读取金额100，修改金额为50，修改version=2 B读取金额为100，修改金额为60，修改version=2 A提交到库，这时有一个判断，如果当前version&gt;库里的version，那么通过，A可以通过 由于A修改了库version=2，B的version没有大于2，被驳回，不可提交 CASCAS 适合简单对象的操作，比如布尔值、整型值等。内部保持着一个volatile修饰的long变量，volatile保证了long的值更新后，其他线程能立即获得最新的值。自旋锁，比较交换算法，需要读写的内存值V，进行比较的值A，拟写入的值B 如果A取到的Value为1,要对value进行加1操作，设置期望值为2 如果B取到的Value为1，要对value进行+1，设置期望值为2 A判断value+1为2，与期望值相等，那么修改Value为2 B判断实际的V+B=3,与期望的2不相等，那么返回失败，继续第二步，这时读出的Value为2,循环一次。 悲观锁传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。 可重入锁不可重入锁AQS实现原理避免死锁分布式锁分布式锁的redis实现方式","categories":[{"name":"spring","slug":"spring","permalink":"http://trembear.github.io/categories/spring/"}],"tags":[]},{"title":"如何设计一款发号器","slug":"java/设计发号器","date":"2019-11-15T09:17:27.000Z","updated":"2019-12-03T07:55:46.091Z","comments":true,"path":"2019/11/15/java/设计发号器/","link":"","permalink":"http://trembear.github.io/2019/11/15/java/设计发号器/","excerpt":"","text":"在单机环境中，遇到生成不重复Id的问题时，我们一般使用数据库自增主键的形式或者UUID的形式，在分布式系统中，我们使用的不止是一台数据库，使用UUID又会遇到内存消耗过大的情况，并且uuid是没有顺序的，导致B+ tree做索引时有太多的随机操作，性能下降。为了解决这个问题，单独抽出ID生成器模块进行不重复的递增ID生成。 要求 全局唯一 基本有序 高性能 高可用 可灵活配置（多种接入方案） 思路该ID二进制总共有64位，具体如下： 版本 类型 生成方式 秒级时间 序列号 机器ID 63 62 60-61 30-59 10-29 0-10 系统采用多模块的结构，分为： intf层：接口模块 service层：提供服务的模块 （引入intf依赖） rest层： 对外提供Rest接口 （引入service依赖） 系统结构为： 各个部分的描述： Id 类为组成ID的各个字段的结构 IdService接口提供了一个生成号码的方法 AbstractIdService是一个抽象类，实现了genId的方法，组装类型，机器ID等六个子字段 1234567891011121314@Overridepublic long genId()&#123; Id id = new Id(); id.setMachine(machineId); id.setGenMethod(genMethod); id.setType(idType.value()); id.setVersion(version); //由子类生成Id的序列号和验证码 populateId(id); //转化id long ret = convert(id, this.idMate); return ret;&#125;protected abstract void populateId(Id id); 子类的初始化 123456789101112131415161718public class IdServiceImpl extends AbstractIdService &#123; //这个类用来生成序列号 IdPopulator idPopulator; public IdServiceImpl() &#123; //父类初始化，设置模式为 秒级 生成，并且设置各个字段所占的字节数 super.init(); initPopulator(); &#125; private void initPopulator() &#123; idPopulator=new SyncIdPopulator(); &#125; @Override protected void populateId(Id id) &#123; idPopulator.populateId(id, this.idMate); &#125;&#125; 父类的初始化 123456789101112131415public abstract class AbstractIdService implements IdService &#123; protected long machineId=1; protected long genMethod=0; protected long version=0; protected IdType idType; protected IdMate idMate; public void init()&#123; //设置为类型为秒级 idType=IdType.SECONDS; //设置各个字段所占的位数 idMate= new IdMate((byte) 10, (byte) 20, (byte) 30, (byte) 2, (byte) 1, (byte) 1); &#125; ...&#125; 具体生成的时间和序列号设计，逻辑如下，通过锁来控制并发问题，这个地方的逻辑可以通过Lock或者自旋锁来进行设计，同一时间里面的序列号地递增，过了当前时间后的时间改变，同时序列号置为0： 1234567891011121314151617181920public class SyncIdPopulator implements IdPopulator &#123; //序列号 private long sequence=0; //时间戳 private long lastTimestamp=-1; @Override public synchronized void populateId(Id id, IdMate idMate) &#123; Timer timer=new SimpleTimer(); long timestamp= timer.genTime(); if(timestamp==lastTimestamp)&#123; sequence++; &#125;else &#123; lastTimestamp=timestamp; sequence=0; &#125; id.setSeq(sequence); id.setTime(timestamp); &#125;&#125; 额外的时间类（SimpleTimer）:时间类用于生成时间的long类型的数值 Abstract类中的拼接，按照更合理的做法，应该是通过IdType类型作判断，然后由工厂类生成指定的拼接方法，这里只是做一个示范： 1234567891011121314151617protected long doConvert(Id id, IdMate idMeta) &#123; long ret = 0; ret |= id.getMachine(); ret |= id.getSeq() &lt;&lt; idMeta.getSeqBitsStartPos(); ret |= id.getTime() &lt;&lt; idMeta.getTimeBitsStartPos(); ret |= id.getGenMethod() &lt;&lt; idMeta.getGenMethodBitsStartPos(); ret |= id.getType() &lt;&lt; idMeta.getTypeBitsStartPos(); ret |= id.getVersion() &lt;&lt; idMeta.getVersionBitsStartPos(); return ret; &#125; 测试: 1234567public class NtTest &#123; @Test public void test1()&#123; IdServiceImpl idService=new IdServiceImpl(); System.out.println(idService.genId()); &#125; &#125; 其他 时间的生成与压缩 如果并发太大，并且超过了同一秒中的所有的最大序列值，那么可以让其自旋等待下一秒 压缩：通过ID中类型来确定时间单位，设置一个基准值，用当前值减去基准值，除以一个位数，进行压缩 机器Id的生成 通过配置，配置每一台机器上不同的机器ID 通过IP来分配一个不同的Id 通过数据库来分配 通过zookeeper来分配一个","categories":[{"name":"spring","slug":"spring","permalink":"http://trembear.github.io/categories/spring/"}],"tags":[]},{"title":"数据库优化","slug":"java/数据库优化","date":"2019-11-15T09:17:27.000Z","updated":"2019-11-15T09:34:25.977Z","comments":true,"path":"2019/11/15/java/数据库优化/","link":"","permalink":"http://trembear.github.io/2019/11/15/java/数据库优化/","excerpt":"","text":"索引失效问题分库分表MyCatSharding-JDBC","categories":[{"name":"spring","slug":"spring","permalink":"http://trembear.github.io/categories/spring/"}],"tags":[]},{"title":"java易错知识点","slug":"java/java易错知识点","date":"2019-11-15T06:58:06.000Z","updated":"2019-12-03T06:33:40.006Z","comments":true,"path":"2019/11/15/java/java易错知识点/","link":"","permalink":"http://trembear.github.io/2019/11/15/java/java易错知识点/","excerpt":"","text":"JVM内存区域 方法区(线程共享):储被 JVM 加载的类信息、 常量、 静态变量、 即时编译器编译后的代码等数据 a. 运行时常量池： 运行期间也可能将新的常量放入池中（常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享） 堆（线程共享）：创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域。 虚拟机栈（线程私有）: 方法执行的内存模型，每个方法执行的时候都会创建栈帧，方法结束出栈。 本地方法区（线程私有）：JVM调用外部的一些栈 程序计数器（线程私有）：当前线程的指示器 IO 阻塞IO 非阻塞IO：客户线程轮询，返回错误结果后继续发起请求。 多路复用IO ：内核轮询，一个线程管理多个来源的IO NIO：Java NIO 实际上就是多路复用IO，创建多个socket。内核不断轮询各个socket 信号驱动IO：发起IO的时候，给socket一个函数，就绪后发送信号给用户线程 异步IO：应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。 类加载机制双亲委派模式： 自底向上检查是否类是否被夹在 自顶向下尝试加载类","categories":[{"name":"java基础","slug":"java基础","permalink":"http://trembear.github.io/categories/java基础/"}],"tags":[]},{"title":"Spring相关知识","slug":"java/Spring应用相关的知识","date":"2019-11-15T06:58:06.000Z","updated":"2019-11-15T09:28:25.216Z","comments":true,"path":"2019/11/15/java/Spring应用相关的知识/","link":"","permalink":"http://trembear.github.io/2019/11/15/java/Spring应用相关的知识/","excerpt":"","text":"","categories":[{"name":"spring","slug":"spring","permalink":"http://trembear.github.io/categories/spring/"}],"tags":[]},{"title":"Redis","slug":"java/Redis","date":"2019-11-15T06:58:06.000Z","updated":"2019-11-15T09:31:51.113Z","comments":true,"path":"2019/11/15/java/Redis/","link":"","permalink":"http://trembear.github.io/2019/11/15/java/Redis/","excerpt":"","text":"缓存一致性集群备份Redis实现排行","categories":[{"name":"spring","slug":"spring","permalink":"http://trembear.github.io/categories/spring/"}],"tags":[]},{"title":"MQ之间的对比","slug":"java/MQ之间的对比","date":"2019-11-15T06:58:06.000Z","updated":"2019-11-15T09:28:25.260Z","comments":true,"path":"2019/11/15/java/MQ之间的对比/","link":"","permalink":"http://trembear.github.io/2019/11/15/java/MQ之间的对比/","excerpt":"","text":"","categories":[{"name":"spring","slug":"spring","permalink":"http://trembear.github.io/categories/spring/"}],"tags":[]},{"title":"dubbo和SpringCloud异同点","slug":"java/dubbo和SpringCloud对比","date":"2019-11-15T06:58:06.000Z","updated":"2019-11-15T06:58:13.067Z","comments":true,"path":"2019/11/15/java/dubbo和SpringCloud对比/","link":"","permalink":"http://trembear.github.io/2019/11/15/java/dubbo和SpringCloud对比/","excerpt":"","text":"","categories":[{"name":"spring","slug":"spring","permalink":"http://trembear.github.io/categories/spring/"}],"tags":[]},{"title":"spring源码阅读4-整体的流程图","slug":"Spring源码阅读/spring源码阅读4","date":"2019-11-15T01:16:35.000Z","updated":"2019-11-28T00:44:53.700Z","comments":true,"path":"2019/11/15/Spring源码阅读/spring源码阅读4/","link":"","permalink":"http://trembear.github.io/2019/11/15/Spring源码阅读/spring源码阅读4/","excerpt":"","text":"回顾了一下一上几节，感觉不是很清晰，同样是针对这个从文件中注入Bean到SpringBeanFactory这个过程，作了如下的流程图： 整体的流程图： 拆分xmlBeanFactory这个super()操作，主要是加载父级的beanFactory。在这个里面父级元素为null 第三步是这个的核心，loadBeanDefinition(resource)的具体流程 以上三步是大概的流程，最后一步中，读取xml是在Document类中具体完成的，但是前置的一些工作在XmlBeanDifinitionReader中完成。 doLoadDocument通过使用DocumentLoader对象来加载Document对象，但这里在使用DocumentLoader对象之前还需要做以下5个准备工作 获取DocumentLoader对象。 获取EntityResolver对象。 获取ErrorHandler对象。 获取xml验证模式。 设置xml命名空间是否敏感 下面是具体如何获取EntityResolver和Xml验证模式的流程图： 当取到Document以后，registerBeanDefinitions操作： 开始注册进入Spring容器：","categories":[{"name":"spring","slug":"spring","permalink":"http://trembear.github.io/categories/spring/"}],"tags":[]},{"title":"高阶组件","slug":"前端/高阶组件","date":"2019-11-09T04:51:47.000Z","updated":"2019-11-09T05:12:18.133Z","comments":true,"path":"2019/11/09/前端/高阶组件/","link":"","permalink":"http://trembear.github.io/2019/11/09/前端/高阶组件/","excerpt":"","text":"问题引入react组件提供了高端组件这么一个说法，高端组件可以部分替代组件之间的继承。是一个修饰器的模式，能够更灵活的处理一些组件复用的问题。高阶组件本质是一个函数，此函数接受一个组件，返回一个新组件。现在有这样一个需求，我们有很多业务，比如用户选择，订单选择，产品选择等。但是选择方式都是通过一个select选择框进行选择的，那么，可以将这个选择框提炼为一个公共组件，各个业务分装为业务组件，在一个实际的操作页面上，只要引入业务组件即可使用所有的功能。 这样的好处有： 新建一个业务组件特别简单，传入业务的url，名称和显示字段后，即可配合通用组件实现一个完整的select选择器。 提高代码的复用性，方便灵活的部署，修改基础组件的逻辑，对所有业务组件产生作用。 操作基础组件 jsx1234567891011121314151617181920212223242526272829303132333435363738class BaseInputComp extends Component&lt;BaseProp, BaseState&gt; &#123; componentDidMount() &#123; const &#123; dispatch &#125; = this.props; dispatch(&#123; type: 'productBrandList/fetchList', payload: &#123; pageSize: 10, &#125;, &#125;); &#125; render() &#123; const &#123;children&#125;=this.props function handleChange(value: any) &#123; console.log(`Selected: $&#123;value&#125;`); &#125; const x = 2 const &#123;url&#125; = this.props return ( &lt;div&gt; &lt;Select size=\"default\" mode=\"multiple\" placeholder=\"Please select\" maxTagCount=&#123;x&#125; defaultValue=&#123;[]&#125; onChange=&#123;handleChange&#125; style=&#123;&#123;width: '250px'&#125;&#125; &gt; &#123;children&#125; &lt;/Select&gt; &#123;url&#125; &lt;/div&gt; ); &#125;&#125;export default BaseInputComp; 基础组件中的高阶组件，提供给人员组件用来进行封装。 jsx12345678910111213141516export function withPersistentData(name: string, url: string) &#123; return (WrappedComponent: any) =&gt; &#123; class NewComponent extends Component&lt;BaseProp, BaseState&gt; &#123; render() &#123; return ( &lt;div&gt; &lt;span&gt;&#123;name&#125;选择&lt;/span&gt; &lt;WrappedComponent url=&#123;url&#125;&#123;...this.props&#125;/&gt; &lt;/div&gt; ) &#125; &#125; return NewComponent &#125;&#125; 人员组件 jsx12345678910111213141516import React, &#123;Component&#125; from \"react\";import BaseInputComp, &#123;withPersistentData&#125; from \"@/components/BaseInputComp\";import &#123;BaseProp, BaseState&#125; from \"@/components/BaseInputComp/model\";interface UserProp extends BaseProp &#123;&#125;interface UserState extends BaseState&#123;&#125;@withPersistentData('人员','/product/info')export default class UserComp extends Component&lt;UserProp, UserState&gt; &#123; render() &#123; return ( &lt;BaseInputComp &#123;...this.props&#125;&gt;&lt;/BaseInputComp&gt; ) &#125;&#125; 使用方法 jsx1234567891011121314151617181920212223242526272829303132333435interface ListProps extends BaseProp &#123; userId: number dispath:Dispatch&#125;interface ListState extends BaseState &#123;&#125;@connect((&#123;exampleDemoModel&#125;: &#123; exampleDemoModel: ExampleDemoType &#125;) =&gt; (&#123;userId: exampleDemoModel.userId&#125;))class ComponentDemo extends Component&lt;ListProps, ListState&gt; &#123; enterIconLoading = () =&gt; &#123; const &#123;dispatch&#125; = this.props; const &#123;userId&#125; = this.props dispatch(&#123; type: \"exampleDemoModel/fetchNum\", payload2: &#123; numCount: userId, &#125; &#125;) &#125;; render() &#123; const &#123;userId&#125; = this.props return ( &lt;div&gt; 当前userId：&#123;userId&#125;&lt;br/&gt;&lt;br/&gt; &lt;Button onClick=&#123;this.enterIconLoading&#125;&gt;切换UserId&lt;/Button&gt;&lt;br/&gt;&lt;br/&gt; &lt;UserComp &#123;...this.props&#125;/&gt; &lt;/div&gt; ) &#125;&#125;export default Form.create&lt;ListProps &amp; FormComponentProps&gt;()(ComponentDemo);","categories":[{"name":"前端","slug":"前端","permalink":"http://trembear.github.io/categories/前端/"}],"tags":[{"name":"react","slug":"react","permalink":"http://trembear.github.io/tags/react/"}]},{"title":"dva connect的用法","slug":"前端/dva connect 具体的用法","date":"2019-11-07T07:18:58.000Z","updated":"2019-11-09T05:12:51.526Z","comments":true,"path":"2019/11/07/前端/dva connect 具体的用法/","link":"","permalink":"http://trembear.github.io/2019/11/07/前端/dva connect 具体的用法/","excerpt":"","text":"问题引入dva一般用connect进行model数据与组件绑定。通过例子来看具体的绑定方式。具体的流程如下： 组件里面有一个按钮，点击按钮进入model层的effect方法 model中的effect执行完毕后，调用reducer刷新model中state值，同时也刷新组件的显示效果 在这个结构里，有一个问题就是组件中显示的值为model中的state，那么这就需要将组件中的数据与model中的state作绑定。 现在有一个组件： jsx12345678910111213141516171819202122232425262728293031323334353637383940interface MyProps&#123; dispatch:Dispatch num:number&#125;interface MyState &#123; num:number iconLoading:boolean&#125;class OtherComponent extends Component&lt;MyProps, MyState&gt; &#123; state = &#123; num:12, iconLoading:false &#125;; enterIconLoading = () =&gt; &#123; const &#123;dispatch&#125;=this.props; this.setState(&#123; iconLoading: true &#125;); const &#123;num&#125; = this.props dispatch(&#123; type: \"otherModel/fetchNum\",// 这里就会触发models层里面effects中fetchNum方法（也可以直接触发reducer中方法，看具体情况） ,test就是models里的命名空间名字 payload2: &#123; numCount:num, &#125; &#125;) this.setState(&#123;iconLoading:false&#125;) &#125;; render() &#123; const &#123;num&#125; = this.props return ( &lt;div&gt; &lt;Button type=\"primary\" icon=\"poweroff\" loading=&#123;this.state.iconLoading&#125; onClick=&#123;this.enterIconLoading&#125;&gt; &#123;num&#125; &lt;/Button&gt; &lt;/div&gt; ) &#125;&#125;export default OtherComponent; model层中代码： jsx12345678910111213141516171819202122232425262728293031323334353637export interface StateType &#123; num: number iconLoading: boolean&#125;export interface ModelType &#123; namespace: string; state: StateType; effects: &#123;&#125;; reducers: &#123;&#125;;&#125;const Model: ModelType = &#123; namespace: 'otherModel', state: &#123;num: 1873, iconLoading: false&#125;, reducers: &#123; addNum(state: StateType, &#123;payload: &#123;num&#125;&#125;:&#123;payload:&#123;num:number&#125;&#125;) &#123; return &#123;...state, num&#125; &#125; &#125;, effects: &#123; * fetchNum(&#123;payload2&#125;: &#123; payload2: AnyAction &#125;, &#123;call,put &#125;: EffectsCommandMap &amp; &#123; select: &lt;T&gt;(func: (state: StateType) =&gt; T) =&gt; T &#125;) &#123;//fetchNum方法名，payload2是传来的参数，是个对象，如果没参数可以写成&#123;_,&#123;call,put,select&#125;&#125; // const &#123;data&#125; = yield call(myService.doit, &#123;anum: payload2.numCount&#125;) // myService是引入service层那个js的一个名字，anum是后台要求传的参数，data就是后台返回来的数据 //const m = yield select((state) =&gt; state.test.num) //select就是用来选择上面state里的，这里没用上 console.log(payload2) yield put(&#123; type: \"addNum\",// 这就是reducer中addNum方法, put就是用来触发上面reducer的方法，payload里就是传过去的参数。 同时它也能触发同等级effects中其他方法。 payload: &#123; num: payload2.numCount + 1, // 把后台返回的数据赋值给了num，假如那个reducer中方法是由这里effects去触发的，那个num名必须是这里名字num，如果reducer中方法不是这触发，那名字可随便起 &#125;, &#125;) &#125; &#125;,&#125;export default Model; 现在可以看到两边的逻辑都已经写好了，看看如何绑定model中的num值。 方法一传统方式,使用connect，在组件中写入。这样写之后，就会在组件的props中生成一个otherModel的属性。使用的时候用const {otherModel}=this.props即可取到。这里的otherModel为model 的命名空间。 jsx1234567function mapStateToProps (model) &#123; const &#123; otherModel&#125; = model return &#123; otherModel,// 在这return,上面才能获取到 &#125;&#125;export default connect(mapStateToProps)(OtherComponent); 如果想使用model state中的某几个属性，那么使用,如下： jsx123456function mapStateToProps (model) &#123; const &#123; num&#125; = model.otherModel return &#123; num,// 在这return,上面才能获取到 &#125;&#125; 方法二现在一般都用@connect装饰器的模式。这种模式看起来更简单一些，但是初次使用，语法上还是需要看一下的： jsx1@connect((&#123;otherModel&#125;:&#123;otherModel:StateType&#125;)=&gt;(&#123;otherModel&#125;)) 在这里需要注意，这样引入的话，类似于上面的全部引入。但是如果想要部分引入属性。需要用下面的方法： jsx1@connect((&#123;otherModel&#125;:&#123;otherModel:StateType&#125;)=&gt;(&#123;num:otherModel.num&#125;)) 即传入的参数永远为otherModel，也就是这个唯一的命名空间","categories":[{"name":"前端","slug":"前端","permalink":"http://trembear.github.io/categories/前端/"}],"tags":[{"name":"react","slug":"react","permalink":"http://trembear.github.io/tags/react/"}]},{"title":"Specification动态构建复杂查询","slug":"JPA/Specification动态构建复杂查询","date":"2019-11-01T07:14:08.000Z","updated":"2019-12-03T07:55:46.057Z","comments":true,"path":"2019/11/01/JPA/Specification动态构建复杂查询/","link":"","permalink":"http://trembear.github.io/2019/11/01/JPA/Specification动态构建复杂查询/","excerpt":"","text":"JPA查询的几种形式 基础形式此种方法不用写sql，继承JpaRepository，适合简单的增删改查。例子：一般针对简单的查询： 12345@Repositorypublic interface ProductAttributeValueRepository extends JpaRepository&lt;ProductAttributeValue,Long&gt; &#123; int deleteAllByCateId(Long id); int deleteAllByAttrNameId(Long id);&#125; SQL,JPQL查询 sql查询为原生SQL查询，JPQL查询是使用的是基于对象的查询。 Modifying:它说的是可以清除底层持久化上下文，就是entityManager这个类，我们知道jpa底层实现会有二级缓存，也就是在更新完数据库后，如果后面去用这个对象，你再去查这个对象，这个对象是在一级缓存，但是并没有跟数据库同步，这个时候用clearAutomatically=true,就会刷新hibernate的一级缓存了 123456@Repositorypublic interface ProductCategoryRepository extends JpaRepository&lt;ProductCategoryEntity, Long&gt; &#123; @Modifying(clearAutomatically = true) @Query(value = \"update product_category pc set pc.`is_delete`=1 where pc.`cate_id`=?1\", nativeQuery = true) int deleteCategoryById(long id);&#125; 组装形式的原生SQL这种形式，适合查询条件比较复杂的情况，自己组装比较灵活 12345678910111213 public ProductInfoDto searchProductInfoWithTitle(Long productInfoId)&#123; String sql = \"select pi.*,pb.title as brand_title,pc.title as category_title from product_info pi \" + \"left join product_brand pb on pi.brand_id=pb.brand_id \" + \"left join product_category pc on pc.cate_id=pi.cate_id \" + \"where pi.id=\" + productInfoId + \" and pi.is_delete=0 \"; List&lt;ProductInfoDto&gt; webInfos = entityManager.createNativeQuery(sql, ProductInfoDto.class).getResultList(); if (webInfos == null || webInfos.size() == 0) &#123; return null; &#125; ProductInfoDto productInfoDto = webInfos.get(0); return productInfoDto;&#125; Querydsl方式 12interface UserRepository extends CrudRepository&lt;User, Long&gt;, QuerydslPredicateExecutor&lt;User&gt; &#123;&#125; 使用方法： 1234Predicate predicate = user.firstname.equalsIgnoreCase(\"dave\") .and(user.lastname.startsWithIgnoreCase(\"mathews\")); userRepository.findAll(predicate); 使用Example我一开始特别喜欢这种形式的查询，比较直观，ExampleMatcher是一个查询的匹配器，可以设置多种匹配规则，分页也比较直观 12345678910111213Sort sort = new Sort(Sort.Direction.DESC, \"brandId\");Pageable pageable = PaginationUtil.pageRequest(productBrandListDtoIn, sort);ExampleMatcher exampleMatcher = ExampleMatcher.matching().withMatcher(\"title\", ExampleMatcher.GenericPropertyMatchers.contains());Example&lt;ProductBrand&gt; example = Example.of(productBrandListDtoIn.getProductBrand(), exampleMatcher);Page&lt;ProductBrand&gt; productBrandPage =productBrandRepository.findAll(example, pageable);ProductBrandListDtoOut dtoOut = new ProductBrandListDtoOut(productBrandPage);if (productBrandPage.getContent().size() &gt; 0) &#123; productBrandPage.getContent().forEach(entity -&gt; dtoOut.getList().add(dtoOut.convertToDto(entity)) );&#125; return dtoOut; nameQuery方法 123456@Entity@NamedQuery(name = \"User.findByEmailAddress\", query = \"select u from User u where u.emailAddress = ?1\")public class User &#123;&#125;","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://trembear.github.io/categories/JAVA/"}],"tags":[{"name":"JPA Specification","slug":"JPA-Specification","permalink":"http://trembear.github.io/tags/JPA-Specification/"}]},{"title":"初次使用ant design pro遇到的问题","slug":"前端/初次使用ant design pro遇到的问题","date":"2019-10-25T17:32:53.000Z","updated":"2019-11-01T07:11:52.463Z","comments":true,"path":"2019/10/26/前端/初次使用ant design pro遇到的问题/","link":"","permalink":"http://trembear.github.io/2019/10/26/前端/初次使用ant design pro遇到的问题/","excerpt":"","text":"原因最近的一个项目，后台框架用的是React。本来以为直接看看项目代码就能照葫芦画瓢的，结果栽了一个跟头，在苦苦挣扎了一天后，还是有很多地方看不懂，晚上冷静了一下，整理了一下看不懂的一些地方，做一下记录，很多时候都是因为TSX的语法不够熟练，导致看不懂，有时间还是要重新学习一下语法,真正要彻底掌握ant design pro,需要前置学习的有es6，ts，react，jsx，dva，umi等。但是项目时间的问题，彻底学习还是留待以后。其实在项目中实际运用可能会更快一些。下面是一些具体的问题 TypeScript泛型的问题函数中的泛型 jsx123456789101112131415161718192021222324252627//定义学生的属性获取方法，一个返回字符串类型的name一个返回number类型的年龄let itemFun = &#123; getName: (name: string): string=&gt;&#123; return name; &#125;, getAge: (age: number):number=&gt;&#123; return age; &#125;&#125;//错误做法，这样的话value没有类型let student1 = (value) =&gt; &#123; return value;&#125;//相当于let student1 = (value: any):any =&gt; &#123; return value;&#125;//错误做法 会找不到T类型的类let student3 = &lt;T&gt;(value: T): T =&gt; &#123; return value;&#125;//规范做法//解释：Value: T 表示声明参数是 T 类型的，后面的 : T 表示返回值也是 T 类型的。let student3 = &lt;T extends &#123;&#125;&gt;(value: T): T =&gt; &#123; return value;&#125; 另外一种形式 jsx123456789101112131415161718192021222324252627// 声明泛型类，类型变量为 Tclass FilteredList&lt;T&gt; &#123; // 声明过滤器是以 T 为参数类型，返回 boolean 的函数表达式 filter: (v: T) =&gt; boolean; // 声明数据是 T 数组类型 data: T[]; //构造器中 传入的filter是一个函数，T为参数，返回值为boolean constructor(filter: (v: T) =&gt; boolean) &#123; this.filter = filter; &#125; add(value: T) &#123; if (this.filter(value)) &#123; this.data.push(value); &#125; &#125; get all(): T[] &#123; return this.data; &#125;&#125;// 处理 string 类型的 FilteredListconst validStrings = new FilteredList&lt;string&gt;(s =&gt; !s);// 处理 number 类型的 FilteredListconst positiveNumber = new FilteredList&lt;number&gt;(n =&gt; n &gt; 0); 最常见一种形式的解释 jsx1234567891011121314151617interface IProps &#123; color?: string; size?: string;&#125;interface IState &#123; aState: string; bState: number;&#125;export default class Animal extends Component&lt;IProps, IState&gt; &#123; constructor(props:IProps) &#123; super(props); this.state = &#123; aState: '', bState: 0 &#125; &#125;&#125; 使用泛型进行 Props、 State 的类型定义。在这个两个泛型里面，前一个为Props，后一个为State。这样写的目的是在定义后使用 this.state 和 this.props 时可以在编辑器中获得更好的智能提示，并且会对类型进行检查。 状态和属性props 是组件对外的接口，state 是组件对内的接口。组件内可以引用其他组件，组件之间的引用形成了一个树状结构（组件树），如果下层组件需要使用上层组件的数据或方法，上层组件就可以通过下层组件的props属性进行传递，因此props是组件对外的接口。组件除了使用上层组件传递的数据外，自身也可能需要维护管理数据，这就是组件对内的接口state。根据对外接口props 和对内接口state，组件计算出对应界面的UI。 主要区别： State是可变的，是一组用于反映组件UI变化的状态集合；state是私有的，可以认为state是组件的“私有属性（或者是局部属性） 而Props对于使用它的组件来说，是只读的，要想修改Props，只能通过该组件的父组件修改。在组件状态上移的场景中，父组件正是通过子组件的Props, 传递给子组件其所需要的状态。 如何修改statesstates有几个地方需要注意 用setState 修改State State 的更新是异步的 State更新会被合并 state类型是数组 state类型是对象向子组件传递数据我们说 props 是组件对外的接口，state 是组件对内的接口。一个组件可以选择将 state(状态) 向下传递，作为其子组件的 props(属性)：jsx1&lt;MyComponent title=&#123;this.state.title&#125;/&gt; 自定义表单组件回传值ant-design给我们提供了Form表单组件,但是如果想把其中的某些输入框转为组件，原有的表单取值和验证使用保持不变，该如何实现：父组件： jsx12345678&lt;FormItem label=\"选项\"&gt; getFieldDecorator('option', &#123; initialValue: [defaultValue.option || '0', defaultValue.word] &#125;)( &lt;OptionSelect/&gt; )&#125;&lt;/FormItem&gt; 父组件使用getFieldDecorator最后可以取到option选项的值。子组件： jsx1234567891011121314151617181920212223242526render() &#123; const &#123;value&#125; = this.props; return( &lt;div&gt; &lt;Select value=&#123;value[0]&#125; onChange=&#123;this.selectChange&#125;&gt; //... &lt;/Select&gt; &lt;Input value=&#123;value[1]&#125; onChange=&#123;this.inputChange&#125;/&gt; &lt;/div&gt; )&#125;selectChange(val) &#123; const &#123;onChange&#125; = this.props; //通知父组件更新 //封装数据传参 let changeVal; //... onChange(changeVal)&#125;inputChange(e) &#123; const &#123;onChange&#125; = this.props;&#125;OptionSelect.propTypes = &#123; value: PropTypes.array, onChange: PropTypes.func&#125;; getFieldDecorator这个方法会向组件注入value参数，onChange方法。子组件通过value参数来初始化值，通过onChange方法通知父组件更新。","categories":[{"name":"前端","slug":"前端","permalink":"http://trembear.github.io/categories/前端/"}],"tags":[{"name":"react","slug":"react","permalink":"http://trembear.github.io/tags/react/"}]},{"title":"node study1","slug":"NodeSutdy/NodeStudy1","date":"2019-10-22T06:48:43.000Z","updated":"2019-10-22T09:30:51.993Z","comments":true,"path":"2019/10/22/NodeSutdy/NodeStudy1/","link":"","permalink":"http://trembear.github.io/2019/10/22/NodeSutdy/NodeStudy1/","excerpt":"","text":"第一个例子使用node引入 http组件，然后监听8888端口： 12345678910111213var http = require('http');http.createServer(function (request, response) &#123; // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain response.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); // 发送响应数据 \"Hello World\" response.end('Hello World\\n');&#125;).listen(8888);// 终端打印如下信息console.log('Server running at http://127.0.0.1:8888/'); 执行node server.js，进入浏览器即可访问该端口 npmNPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种： 允许用户从NPM服务器下载别人编写的第三方包到本地使用。 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。 使用淘宝镜像 npm install -g cnpm --registry=https://registry.npm.taobao.org 安装express（Node.js web的框架模块）的命令：npm install express 回调函数Node.js 异步编程的直接体现就是回调。异步编程依托于回调来实现。 阻塞代码： 123456//引入读取文件的模块var fs=require(\"fs\")//阻塞代码var date=fs.readFileSync('server.js' );console.log(date.toString())console.log(\"程序结束\") 非阻塞代码： 123456789var fs=require(\"fs\")//引入读取文件的模块fs.readFile('server.js',function (err,date) &#123; if(err) return console.log(err) else return console.log(date.toString())&#125;)console.log(\"程序执行结束!\");//执行结果：此句话先输出 ##事件驱动程序Node.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。这个模型非常高效可扩展性非常强，因为webserver一直接受请求而不等待任何读写操作。（这也被称之为非阻塞式IO或者事件驱动IO）类似于观察者模式，事件相当于一个主题(Subject)，而所有注册到这个事件上的处理函数相当于观察者(Observer)。示例： 12345678910111213141516171819202122232425// 引入 events 模块var events = require('events');// 创建 eventEmitter 对象var eventEmitter = new events.EventEmitter(); // 创建事件处理程序var connectHandler = function connected() &#123; console.log('连接成功。'); // 触发 data_received 事件 eventEmitter.emit('data_received');&#125; // 绑定 connection 事件处理程序eventEmitter.on('connection', connectHandler); // 使用匿名函数绑定 data_received 事件eventEmitter.on('data_received', function()&#123; console.log('数据接收成功。');&#125;); // 触发 connection 事件 eventEmitter.emit('connection'); console.log(\"程序执行完毕。\"); EventEmitterNode.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。 Node.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。 EventEmitter 的核心就是事件触发与事件监听器功能的封装 常见的EventEmitter执行方法有： Tables: 方法 描述 addListener(event, listener) 为指定事件添加一个监听器到监听器数组的尾部。 on(event, listener) 为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。 once(event, listener) 为指定事件注册一个单次监听器，即 监听器最多只会触发一次。 removeListener(event, listener) 移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。 removeAllListeners(event, listener) 移除所有事件的所有监听器。 setMaxListeners(n) EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 listeners(event) 返回指定事件的监听器数组。 emit(event, [arg1], [arg2], […]) 按监听器的顺序执行执行每个监听器。 buffer","categories":[{"name":"spring","slug":"spring","permalink":"http://trembear.github.io/categories/spring/"}],"tags":[]},{"title":"mybatis-generator 配置详解","slug":"mybatis-generator 配置详解","date":"2019-07-20T09:39:00.000Z","updated":"2019-10-22T01:43:07.409Z","comments":true,"path":"2019/07/20/mybatis-generator 配置详解/","link":"","permalink":"http://trembear.github.io/2019/07/20/mybatis-generator 配置详解/","excerpt":"","text":"概述MyBatis官方提供了逆向工程 mybatis-generator，可以针对数据库表自动生成MyBatis执行所需要的代码（如Mapper.java、Mapper.xml、POJO）。mybatis-generator 有三种用法：命令行、eclipse插件、maven插件。而maven插件的方式比较通用，本文也将概述maven插件的使用方式。 配置形式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"\"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;&lt;!-- 配置生成器 --&gt;&lt;generatorConfiguration&gt;&lt;!-- 可以用于加载配置项或者配置文件，在整个配置文件中就可以使用$&#123;propertyKey&#125;的方式来引用配置项 resource：配置资源加载地址，使用resource，MBG从classpath开始找，比如com/myproject/generatorConfig.properties url：配置资源加载地质，使用URL的方式，比如file:///C:/myfolder/generatorConfig.properties. 注意，两个属性只能选址一个; 另外，如果使用了mybatis-generator-maven-plugin，那么在pom.xml中定义的properties都可以直接在generatorConfig.xml中使用&lt;properties resource=\"\" url=\"\" /&gt; --&gt; &lt;!-- 在MBG工作的时候，需要额外加载的依赖包 location属性指明加载jar/zip包的全路径&lt;classPathEntry location=\"/Program Files/IBM/SQLLIB/java/db2java.zip\" /&gt; --&gt; &lt;!-- context:生成一组对象的环境 id:必选，上下文id，用于在生成错误时提示 defaultModelType:指定生成对象的样式 1，conditional：类似hierarchical； 2，flat：所有内容（主键，blob）等全部生成在一个对象中； 3，hierarchical：主键生成一个XXKey对象(key class)，Blob等单独生成一个对象，其他简单属性在一个对象中(record class) targetRuntime: 1，MyBatis3：默认的值，生成基于MyBatis3.x以上版本的内容，包括XXXBySample； 2，MyBatis3Simple：类似MyBatis3，只是不生成XXXBySample； introspectedColumnImpl：类全限定名，用于扩展MBG--&gt;&lt;context id=\"mysql\" defaultModelType=\"hierarchical\" targetRuntime=\"MyBatis3Simple\" &gt; &lt;!-- 自动识别数据库关键字，默认false，如果设置为true，根据SqlReservedWords中定义的关键字列表； 一般保留默认值，遇到数据库关键字（Java关键字），使用columnOverride覆盖 --&gt; &lt;property name=\"autoDelimitKeywords\" value=\"false\"/&gt; &lt;!-- 生成的Java文件的编码 --&gt; &lt;property name=\"javaFileEncoding\" value=\"UTF-8\"/&gt; &lt;!-- 格式化java代码 --&gt; &lt;property name=\"javaFormatter\" value=\"org.mybatis.generator.api.dom.DefaultJavaFormatter\"/&gt; &lt;!-- 格式化XML代码 --&gt; &lt;property name=\"xmlFormatter\" value=\"org.mybatis.generator.api.dom.DefaultXmlFormatter\"/&gt; &lt;!-- beginningDelimiter和endingDelimiter：指明数据库的用于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是`反引号； --&gt; &lt;property name=\"beginningDelimiter\" value=\"`\"/&gt; &lt;property name=\"endingDelimiter\" value=\"`\"/&gt; &lt;!-- 必须要有的，使用这个配置链接数据库 @TODO:是否可以扩展 --&gt; &lt;jdbcConnection driverClass=\"com.mysql.jdbc.Driver\" connectionURL=\"jdbc:mysql:///pss\" userId=\"root\" password=\"admin\"&gt; &lt;!-- 这里面可以设置property属性，每一个property属性都设置到配置的Driver上 --&gt; &lt;/jdbcConnection&gt; &lt;!-- java类型处理器 用于处理DB中的类型到Java中的类型，默认使用JavaTypeResolverDefaultImpl； 注意一点，默认会先尝试使用Integer，Long，Short等来对应DECIMAL和 NUMERIC数据类型； --&gt; &lt;javaTypeResolver type=\"org.mybatis.generator.internal.types.JavaTypeResolverDefaultImpl\"&gt; &lt;!-- true：使用BigDecimal对应DECIMAL和 NUMERIC数据类型 false：默认, scale&gt;0;length&gt;18：使用BigDecimal; scale=0;length[10,18]：使用Long； scale=0;length[5,9]：使用Integer； scale=0;length&lt;5：使用Short； --&gt; &lt;property name=\"forceBigDecimals\" value=\"false\"/&gt; &lt;/javaTypeResolver&gt; &lt;!-- java模型创建器，是必须要的元素 负责：1，key类（见context的defaultModelType）；2，java类；3，查询类 targetPackage：生成的类要放的包，真实的包受enableSubPackages属性控制； targetProject：目标项目，指定一个存在的目录下，生成的内容会放到指定目录中，如果目录不存在，MBG不会自动建目录 --&gt; &lt;javaModelGenerator targetPackage=\"com._520it.mybatis.domain\" targetProject=\"src/main/java\"&gt; &lt;!-- for MyBatis3/MyBatis3Simple 自动为每一个生成的类创建一个构造方法，构造方法包含了所有的field；而不是使用setter； --&gt; &lt;property name=\"constructorBased\" value=\"false\"/&gt; &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt; &lt;property name=\"enableSubPackages\" value=\"true\"/&gt; &lt;!-- for MyBatis3 / MyBatis3Simple 是否创建一个不可变的类，如果为true， 那么MBG会创建一个没有setter方法的类，取而代之的是类似constructorBased的类 --&gt; &lt;property name=\"immutable\" value=\"false\"/&gt; &lt;!-- 设置一个根对象， 如果设置了这个根对象，那么生成的keyClass或者recordClass会继承这个类；在Table的rootClass属性中可以覆盖该选项 注意：如果在key class或者record class中有root class相同的属性，MBG就不会重新生成这些属性了，包括： 1，属性名相同，类型相同，有相同的getter/setter方法； --&gt; &lt;property name=\"rootClass\" value=\"com._520it.mybatis.domain.BaseDomain\"/&gt; &lt;!-- 设置是否在getter方法中，对String类型字段调用trim()方法 --&gt; &lt;property name=\"trimStrings\" value=\"true\"/&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成SQL map的XML文件生成器， 注意，在Mybatis3之后，我们可以使用mapper.xml文件+Mapper接口（或者不用mapper接口）， 或者只使用Mapper接口+Annotation，所以，如果 javaClientGenerator配置中配置了需要生成XML的话，这个元素就必须配置 targetPackage/targetProject:同javaModelGenerator --&gt; &lt;sqlMapGenerator targetPackage=\"com._520it.mybatis.mapper\" targetProject=\"src/main/resources\"&gt; &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt; &lt;property name=\"enableSubPackages\" value=\"true\"/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 对于mybatis来说，即生成Mapper接口，注意，如果没有配置该元素，那么默认不会生成Mapper接口 targetPackage/targetProject:同javaModelGenerator type：选择怎么生成mapper接口（在MyBatis3/MyBatis3Simple下）： 1，ANNOTATEDMAPPER：会生成使用Mapper接口+Annotation的方式创建（SQL生成在annotation中），不会生成对应的XML； 2，MIXEDMAPPER：使用混合配置，会生成Mapper接口，并适当添加合适的Annotation，但是XML会生成在XML中； 3，XMLMAPPER：会生成Mapper接口，接口完全依赖XML； 注意，如果context是MyBatis3Simple：只支持ANNOTATEDMAPPER和XMLMAPPER --&gt; &lt;javaClientGenerator targetPackage=\"com._520it.mybatis.mapper\" type=\"ANNOTATEDMAPPER\" targetProject=\"src/main/java\"&gt; &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt; &lt;property name=\"enableSubPackages\" value=\"true\"/&gt; &lt;!-- 可以为所有生成的接口添加一个父接口，但是MBG只负责生成，不负责检查 &lt;property name=\"rootInterface\" value=\"\"/&gt; --&gt; &lt;/javaClientGenerator&gt; &lt;!-- 选择一个table来生成相关文件，可以有一个或多个table，必须要有table元素 选择的table会生成一下文件： 1，SQL map文件 2，生成一个主键类； 3，除了BLOB和主键的其他字段的类； 4，包含BLOB的类； 5，一个用户生成动态查询的条件类（selectByExample, deleteByExample），可选； 6，Mapper接口（可选） tableName（必要）：要生成对象的表名； 注意：大小写敏感问题。正常情况下，MBG会自动的去识别数据库标识符的大小写敏感度，在一般情况下，MBG会 根据设置的schema，catalog或tablename去查询数据表，按照下面的流程： 1，如果schema，catalog或tablename中有空格，那么设置的是什么格式，就精确的使用指定的大小写格式去查询； 2，否则，如果数据库的标识符使用大写的，那么MBG自动把表名变成大写再查找； 3，否则，如果数据库的标识符使用小写的，那么MBG自动把表名变成小写再查找； 4，否则，使用指定的大小写格式查询； 另外的，如果在创建表的时候，使用的\"\"把数据库对象规定大小写，就算数据库标识符是使用的大写，在这种情况下也会使用给定的大小写来创建表名； 这个时候，请设置delimitIdentifiers=\"true\"即可保留大小写格式； 可选： 1，schema：数据库的schema； 2，catalog：数据库的catalog； 3，alias：为数据表设置的别名，如果设置了alias，那么生成的所有的SELECT SQL语句中，列名会变成：alias_actualColumnName 4，domainObjectName：生成的domain类的名字，如果不设置，直接使用表名作为domain类的名字；可以设置为somepck.domainName，那么会自动把domainName类再放到somepck包里面； 5，enableInsert（默认true）：指定是否生成insert语句； 6，enableSelectByPrimaryKey（默认true）：指定是否生成按照主键查询对象的语句（就是getById或get）； 7，enableSelectByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询语句； 8，enableUpdateByPrimaryKey（默认true）：指定是否生成按照主键修改对象的语句（即update)； 9，enableDeleteByPrimaryKey（默认true）：指定是否生成按照主键删除对象的语句（即delete）； 10，enableDeleteByExample（默认true）：MyBatis3Simple为false，指定是否生成动态删除语句； 11，enableCountByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询总条数语句（用于分页的总条数查询）； 12，enableUpdateByExample（默认true）：MyBatis3Simple为false，指定是否生成动态修改语句（只修改对象中不为空的属性）； 13，modelType：参考context元素的defaultModelType，相当于覆盖； 14，delimitIdentifiers：参考tableName的解释，注意，默认的delimitIdentifiers是双引号，如果类似MYSQL这样的数据库，使用的是`（反引号，那么还需要设置context的beginningDelimiter和endingDelimiter属性） 15，delimitAllColumns：设置是否所有生成的SQL中的列名都使用标识符引起来。默认为false，delimitIdentifiers参考context的属性 注意，table里面很多参数都是对javaModelGenerator，context等元素的默认属性的一个复写； --&gt; &lt;table tableName=\"userinfo\" &gt; &lt;!-- 参考 javaModelGenerator 的 constructorBased属性--&gt; &lt;property name=\"constructorBased\" value=\"false\"/&gt; &lt;!-- 默认为false，如果设置为true，在生成的SQL中，table名字不会加上catalog或schema； --&gt; &lt;property name=\"ignoreQualifiersAtRuntime\" value=\"false\"/&gt; &lt;!-- 参考 javaModelGenerator 的 immutable 属性 --&gt; &lt;property name=\"immutable\" value=\"false\"/&gt; &lt;!-- 指定是否只生成domain类，如果设置为true，只生成domain类，如果还配置了sqlMapGenerator，那么在mapper XML文件中，只生成resultMap元素 --&gt; &lt;property name=\"modelOnly\" value=\"false\"/&gt; &lt;!-- 参考 javaModelGenerator 的 rootClass 属性 &lt;property name=\"rootClass\" value=\"\"/&gt; --&gt; &lt;!-- 参考javaClientGenerator 的 rootInterface 属性 &lt;property name=\"rootInterface\" value=\"\"/&gt; --&gt; &lt;!-- 如果设置了runtimeCatalog，那么在生成的SQL中，使用该指定的catalog，而不是table元素上的catalog &lt;property name=\"runtimeCatalog\" value=\"\"/&gt; --&gt; &lt;!-- 如果设置了runtimeSchema，那么在生成的SQL中，使用该指定的schema，而不是table元素上的schema &lt;property name=\"runtimeSchema\" value=\"\"/&gt; --&gt; &lt;!-- 如果设置了runtimeTableName，那么在生成的SQL中，使用该指定的tablename，而不是table元素上的tablename &lt;property name=\"runtimeTableName\" value=\"\"/&gt; --&gt; &lt;!-- 注意，该属性只针对MyBatis3Simple有用； 如果选择的runtime是MyBatis3Simple，那么会生成一个SelectAll方法，如果指定了selectAllOrderByClause，那么会在该SQL中添加指定的这个order条件； --&gt; &lt;property name=\"selectAllOrderByClause\" value=\"age desc,username asc\"/&gt; &lt;!-- 如果设置为true，生成的model类会直接使用column本身的名字，而不会再使用驼峰命名方法，比如BORN_DATE，生成的属性名字就是BORN_DATE,而不会是bornDate --&gt; &lt;property name=\"useActualColumnNames\" value=\"false\"/&gt; &lt;!-- generatedKey用于生成生成主键的方法， 如果设置了该元素，MBG会在生成的&lt;insert&gt;元素中生成一条正确的&lt;selectKey&gt;元素，该元素可选 column:主键的列名； sqlStatement：要生成的selectKey语句，有以下可选项： Cloudscape:相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL() DB2 :相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL() DB2_MF :相当于selectKey的SQL为：SELECT IDENTITY_VAL_LOCAL() FROM SYSIBM.SYSDUMMY1 Derby :相当于selectKey的SQL为：VALUES IDENTITY_VAL_LOCAL() HSQLDB :相当于selectKey的SQL为：CALL IDENTITY() Informix :相当于selectKey的SQL为：select dbinfo('sqlca.sqlerrd1') from systables where tabid=1 MySql :相当于selectKey的SQL为：SELECT LAST_INSERT_ID() SqlServer :相当于selectKey的SQL为：SELECT SCOPE_IDENTITY() SYBASE :相当于selectKey的SQL为：SELECT @@IDENTITY JDBC :相当于在生成的insert元素上添加useGeneratedKeys=\"true\"和keyProperty属性 &lt;generatedKey column=\"\" sqlStatement=\"\"/&gt; --&gt; &lt;!-- 该元素会在根据表中列名计算对象属性名之前先重命名列名，非常适合用于表中的列都有公用的前缀字符串的时候， 比如列名为：CUST_ID,CUST_NAME,CUST_EMAIL,CUST_ADDRESS等； 那么就可以设置searchString为\"^CUST_\"，并使用空白替换，那么生成的Customer对象中的属性名称就不是 custId,custName等，而是先被替换为ID,NAME,EMAIL,然后变成属性：id，name，email； 注意，MBG是使用java.util.regex.Matcher.replaceAll来替换searchString和replaceString的， 如果使用了columnOverride元素，该属性无效； &lt;columnRenamingRule searchString=\"\" replaceString=\"\"/&gt; --&gt; &lt;!-- 用来修改表中某个列的属性，MBG会使用修改后的列来生成domain的属性； column:要重新设置的列名； 注意，一个table元素中可以有多个columnOverride元素哈~ --&gt; &lt;columnOverride column=\"username\"&gt; &lt;!-- 使用property属性来指定列要生成的属性名称 --&gt; &lt;property name=\"property\" value=\"userName\"/&gt; &lt;!-- javaType用于指定生成的domain的属性类型，使用类型的全限定名 &lt;property name=\"javaType\" value=\"\"/&gt; --&gt; &lt;!-- jdbcType用于指定该列的JDBC类型 &lt;property name=\"jdbcType\" value=\"\"/&gt; --&gt; &lt;!-- typeHandler 用于指定该列使用到的TypeHandler，如果要指定，配置类型处理器的全限定名 注意，mybatis中，不会生成到mybatis-config.xml中的typeHandler 只会生成类似：where id = #&#123;id,jdbcType=BIGINT,typeHandler=com._520it.mybatis.MyTypeHandler&#125;的参数描述 &lt;property name=\"jdbcType\" value=\"\"/&gt; --&gt; &lt;!-- 参考table元素的delimitAllColumns配置，默认为false &lt;property name=\"delimitedColumnName\" value=\"\"/&gt; --&gt; &lt;/columnOverride&gt; &lt;!-- ignoreColumn设置一个MGB忽略的列，如果设置了改列，那么在生成的domain中，生成的SQL中，都不会有该列出现 column:指定要忽略的列的名字； delimitedColumnName：参考table元素的delimitAllColumns配置，默认为false 注意，一个table元素中可以有多个ignoreColumn元素 &lt;ignoreColumn column=\"deptId\" delimitedColumnName=\"\"/&gt; --&gt; &lt;/table&gt; &lt;/context&gt; &lt;/generatorConfiguration&gt;","categories":[{"name":"spring","slug":"spring","permalink":"http://trembear.github.io/categories/spring/"}],"tags":[]},{"title":"spring源码阅读3-四个默认标签解析","slug":"Spring源码阅读/spring源码阅读3","date":"2019-07-03T09:39:00.000Z","updated":"2019-10-22T01:35:29.719Z","comments":true,"path":"2019/07/03/Spring源码阅读/spring源码阅读3/","link":"","permalink":"http://trembear.github.io/2019/07/03/Spring源码阅读/spring源码阅读3/","excerpt":"","text":"上一篇是关于解析xml文件的内容，在XmlBeanDefinitionReader类中，主要是doLoadBeanDefinitions方法中的解析步骤，这一篇继续跟进注册步骤。在接下来的过程中，resource被包装为XmlReaderContext，Document转为Element，被documentReader注册到spring中。在具体的doRegisterBeanDefinitions方法中，包含了具体的注册流程parseBeanDefinitions方法。","categories":[{"name":"spring","slug":"spring","permalink":"http://trembear.github.io/categories/spring/"}],"tags":[]},{"title":"面向服务的架构相关的一些概念","slug":"面向服务架构的概念","date":"2019-07-03T09:39:00.000Z","updated":"2019-10-22T01:40:34.340Z","comments":true,"path":"2019/07/03/面向服务架构的概念/","link":"","permalink":"http://trembear.github.io/2019/07/03/面向服务架构的概念/","excerpt":"","text":"关于软件系统的架构设计，是一个太多人喜欢讨论的问题，尤其是对软件开发不了解的人士来说，总是被各种各样的概念绕来绕去。从更高的层次，能够很清晰的列出这些众多概念的区别，而身在开发一线的我们更多的是对这些概念有一些感性的、朴素的认识。将之内化到自己的工作中去，才能更好的发挥架构的优势。 ##微服务和SOA的区别微服务(MSA)是SOA发展出来的产物，它是一种比较现代化的细粒度的SOA实现方式. ##ESBESB(enterprise service bus)曾经着实跟随着SOA火了一阵子，从名称就能知道，它的概念借鉴了计算机组成原理中的通信模型——总线，所有需要和外部系统通信的系统，统统接入ESB，岂不是完美地兼容了现有的互相隔离的异构系统，可以利用现有的系统构建一个全新的松耦合的异构的分布式系统。 但，实际使用中，它还是会有很多的缺点，首先就是ESB的本身就很复杂，大大增加了系统的复杂性和可维护性。其次就是由于ESB想要做到所有服务都通过一个通路通信，直接降低了通信速度。 而在现代的微服务中，往往是一个「富终端、瘦通信」（Smart endpoints and dumb pipes），使用轻量级的通信机制，而每个终端（服务）有自己的处理逻辑，它知道它要找的服务在哪里，不需要在通信的链路上做什么事情。 然而，ESB是一个历史产物，用今天的眼光看待它，并且将之当做SOA的一个标签是不合理不公平的。 ##通讯协议如今越来越多的工程开始使用RESTful来作为API的设计的基础，但仅仅几年前还有大把的API使用SOAP、WSDL等基于XML的重量级协议的Web Service。 这点和上文说到的2点其实大同小异，仔细想想，它们都是由于历史原因造成的，同样的，通信协议经过这些年的发展，现在主流的基本上了两种： 文本协议使用最广泛的多是基于HTTP的RESTful规范 轻量级二进制协议Thrift、Protobuf，或者任何自定义的轻量级协议###SOAPsoap用来描述传递信息的格式 ###WSDLWSDL 用来描述如何访问具体的接口 ###UDDIuddi用来管理，分发，查询webService ##实例服务端客户端 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import java.io.ByteArrayOutputStream;import java.io.DataOutputStream;import java.io.InputStream;import java.net.HttpURLConnection;import java.net.URL;import java.util.HashMap;import java.util.Map;/** * description * * @author Junwei.Xiong * since 2019-07-30 9:56 */public class HttpTest &#123; static String endpointUrl = \"http://localhost:8080/Service/TestServer?wsdl\"; public static Map&lt;String, String&gt; doRequestWS(URL url, String request) &#123; HttpURLConnection connection = null; String rspMsg = \"\"; String rspCode = \"ERROR\"; try &#123; byte[] requestBuf = (byte[]) null; requestBuf = request.getBytes(\"utf-8\"); connection = (HttpURLConnection) url.openConnection(); connection.setDoOutput(true); connection.setDoInput(true); connection.setRequestMethod(\"POST\"); connection.setUseCaches(false); connection.setRequestProperty(\"Content-Type\", \"text/xml\"); connection.connect(); DataOutputStream out = new DataOutputStream( connection.getOutputStream()); out.write(requestBuf); out.flush(); out.close(); if (connection.getResponseCode() != 200) &#123; System.out.println(\"ERROR: \" + connection.getResponseMessage()); &#125; InputStream in = connection.getInputStream(); ByteArrayOutputStream bufOut = new ByteArrayOutputStream(); byte[] readBuf = new byte[100]; while (true) &#123; int ret = in.read(readBuf); if (ret &lt; 0)&#123; break; &#125; bufOut.write(readBuf, 0, ret); &#125; byte[] rspBuf = bufOut.toByteArray(); rspMsg = new String(rspBuf, \"gbk\"); rspCode = connection.getResponseMessage(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; connection = null; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(\"rspCode\", rspCode); map.put(\"rspMsg\", rspMsg); return map; &#125; public static void main(String[] args) throws Exception &#123; StringBuffer sb = new StringBuffer(\"\"); sb.append(\"&lt;?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?&gt;\"); sb.append(\"&lt;soap:Envelope \" + \"xmlns:api='http://service.trembear.com/' \" + \"xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' \" + \"xmlns:xsd='http://www.w3.org/2001/XMLSchema' \" + \"xmlns:soap='http://schemas.xmlsoap.org/soap/envelope/'&gt;\"); sb.append(\"&lt;soap:Body&gt;\"); sb.append(\"&lt;api:helloTest&gt;\"); sb.append(\"&lt;arg0&gt;ls&lt;/arg0&gt;\"); sb.append(\"&lt;/api:helloTest&gt;\"); sb.append(\"&lt;/soap:Body&gt;\"); sb.append(\"&lt;/soap:Envelope&gt;\"); Map&lt;String, String&gt; map = HttpTest.doRequestWS( new URL(endpointUrl), sb.toString()); System.out.println(map); &#125;&#125; 先执行服务端，启动服务，然后执行客户端发起调用。调用的结果如下，可以看到已经有值返回了。同样的方法在postman中也是能获取到返回值的 在上面的例子中，很好看出，这个传入的参数（以&lt;soap:Envelope开头的）即是soap。 从http://localhost:8080/Service/TestServer?wsdl这个访问浏览器返回的即是wsdl。从wsdl中可以看出这个接口中包含了那些具体的接口，以及需要传入的参数。","categories":[{"name":"spring","slug":"spring","permalink":"http://trembear.github.io/categories/spring/"}],"tags":[]},{"title":"spring源码阅读2-项目加载配置文件流程","slug":"Spring源码阅读/spring源码阅读2","date":"2019-07-02T09:39:00.000Z","updated":"2019-10-22T01:33:52.473Z","comments":true,"path":"2019/07/02/Spring源码阅读/spring源码阅读2/","link":"","permalink":"http://trembear.github.io/2019/07/02/Spring源码阅读/spring源码阅读2/","excerpt":"","text":"加载流程针对以下的例子: 12345678public class AppTest &#123; @Test public void test() &#123; BeanFactory bf = new XmlBeanFactory( new ClassPathResource(\"spring-config.xml\")); MyTestBean myTestBean = (MyTestBean) bf.getBean(\"myTestBean\"); Assert.assertEquals(\"testName\",myTestBean.getName()); &#125;&#125; 大致的流程如下： 设置配置文件位置 读取并且校验配置文件 将XML文件转为doc文档 注册doc中的Bean到 第一句话可以拆分为两句： 12Resource resource=new ClassPathResource(\"spring-config.xml\");BeanFactory bf = new XmlBeanFactory(resource); Resource是用于从实际类型的底层资源（例如文件或类路径资源）中抽象的资源描述符的接口。ClassPathResource在加载时，会调用系统的加载classLoader类，加载依赖的class。 123456789public ClassPathResource(String path, ClassLoader classLoader) &#123; Assert.notNull(path, \"Path must not be null\"); String pathToUse = StringUtils.cleanPath(path); if (pathToUse.startsWith(\"/\")) &#123; pathToUse = pathToUse.substring(1); &#125; this.path = pathToUse; this.classLoader = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader());&#125; 拿到resource之后，进入XmlBeanFactory。构造器里有两个主要的方法 123456public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException &#123; //初始化BeanFactory super(parentBeanFactory); //加载resource文件 this.reader.loadBeanDefinitions(resource);&#125; 跟踪super(parentBeanFactory);跟到最后，是 1234567//忽略给定接口的自动装配，如果A中包含了B，在你注入A的时候，会自动注入B，下面是取消自动注入的代码 public AbstractAutowireCapableBeanFactory() &#123; super(); ignoreDependencyInterface(BeanNameAware.class); ignoreDependencyInterface(BeanFactoryAware.class); ignoreDependencyInterface(BeanClassLoaderAware.class);&#125; this.reader.loadBeanDefinitions(resource); 在调用这个方法的时候，会将resource自动封装为EncodedResource，在这之前，this.reader已经初始化 了,这个初始化为后面的获取实体检验加载器，提供了ResourceLoader。 1private final XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(this); 后面在XmlBeanDefinitionReader加载代码为 123456InputStream inputStream = encodedResource.getResource().getInputStream();InputSource inputSource = new InputSource(inputStream);if (encodedResource.getEncoding() != null) &#123; inputSource.setEncoding(encodedResource.getEncoding());&#125;return doLoadBeanDefinitions(inputSource, encodedResource.getResource()); 将文件转为输入流，InputSource不仅包含了InputSource中的内容和编码。继续向下 12345678int doLoadBeanDefinitions(InputSource inputSource, Resource resource)&#123; //读取检验模式（dtd/xsd...） int validationMode = getValidationModeForResource(resource); //将文件流转为Document格式，树状结构 Document doc = this.documentLoader.loadDocument( inputSource, getEntityResolver(), this.errorHandler, validationMode,isNamespaceAware()); return registerBeanDefinitions(doc, resource);&#125; isNamespaceAware()返回XML解析器是否应该支持XML命名空间。 在getEntityResolver()中，在初始化reader的时候，ResourceLoader不为空了，执行的是 12//entityResolver开始为空，resourceLoader为默认的ClassLoaderthis.entityResolver = new ResourceEntityResolver(resourceLoader); ResourceEntityResolver类图如下:ResourceEntityResolver不是spring提供的包，没有继续跟下去了。接着往下看： 12345...private DocumentLoader documentLoader = new DefaultDocumentLoader();...Document doc = this.documentLoader.loadDocument( inputSource, getEntityResolver(), this.errorHandler, validationMode, isNamespaceAware()); 12345678910public Document loadDocument(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception &#123; DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware); if (logger.isDebugEnabled()) &#123; logger.debug(\"Using JAXP provider [\" + factory.getClass().getName() + \"]\"); &#125; DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler); return builder.parse(inputSource);&#125; 具体的如何转换可以继续跟，留着以后看，这里应该还包含了从远程下载dtd,xsd约束文件的代码，这个地方先跳过去。回到XmlBeanDefinitionReader.java中的registerBeanDefinitions(doc, resource)中来， 12345678910public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123; BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); //Environment()从环境中取，与profile字段有关，如果xml中有profile的环境设置，会改变这个值 documentReader.setEnvironment(getEnvironment()); //原有的BeanDefinitionRegistry 仓库 int countBefore = getRegistry().getBeanDefinitionCount(); //加载doc documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); return getRegistry().getBeanDefinitionCount() - countBefore;&#125; createReaderContext(resource)方法获取在bean读取过程中传递的上下文。 registerBeanDefinitions(doc, createReaderContext(resource))跟踪下去，一直到doRegisterBeanDefinitions方法，代码如下： 12345678910111213141516protected void doRegisterBeanDefinitions(Element root) &#123; String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); if (StringUtils.hasText(profileSpec)) &#123; String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); if (!getEnvironment().acceptsProfiles(specifiedProfiles)) &#123; return; &#125; &#125; BeanDefinitionParserDelegate parent = this.delegate; this.delegate = createDelegate(this.readerContext, root, parent); preProcessXml(root); parseBeanDefinitions(root, this.delegate); postProcessXml(root); this.delegate = parent; &#125; 在这段代码中，preProcessXml和postProcessXml两个方法都是空的，给后来的程序进行扩展，貌似在spring-context中，就有对其扩展的例子 一些补充SAX application: JAVA 解析 XML 通常有两种方式:DOM 和SAX。DOM（文档对象模型）是W3C标准，提供了标准的解析方式，但其解析效率一直不尽如人意，这是因为DOM解析XML文档时，把所有内容一次性的装载入内存，并构建一个驻留在内存中的树状结构（节点树）。如果需要解析的XML文档过大，或者我们只对该文档中的一部分感兴趣，这样就会引起性能问题。 EntityResolver: 如果SAX应用程序实现自定义处理外部实体,则必须实现此接口。Sax 解析xml时需要查找对应的dtd定义。EntityResolver申明了一个如何查询dtd的方法。 对于不同的验证模式，spring使用了不同的解析器进行解析。 例如在DelegatingEntityResolver中，加载dtd类型的BeansDtdResolver。加载xsd类型的PluggableEntityResolver，两个的解析模式不一样。 在关于Document是怎么解析这个resolveEntity的具体流程，是在com.sun.org.apache包中实现的，大概的流程如下：","categories":[{"name":"spring","slug":"spring","permalink":"http://trembear.github.io/categories/spring/"}],"tags":[]},{"title":"spring源码阅读1-项目的搭建与导入","slug":"Spring源码阅读/spring源码阅读1","date":"2019-07-01T09:39:00.000Z","updated":"2019-10-22T01:20:39.887Z","comments":true,"path":"2019/07/01/Spring源码阅读/spring源码阅读1/","link":"","permalink":"http://trembear.github.io/2019/07/01/Spring源码阅读/spring源码阅读1/","excerpt":"","text":"spring项目下载源码对应的书籍为《spring源码深度解析》，由于出书也有一段时间，为了便于对照着学习，所以准备下载的源码为3.2.x版本，下载地址为：https://github.com/spring-projects/spring-framework/tree/3.2.x。 部署现在github上的spring项目都是由gradle部署的，所以自己电脑需要提前安装gradle工具，类似于maven，配置好环境后，可以让其更方便的执行。 下载完成后，可以看到项目根目录中有一个readme.md和import-into-idea.md两个文件。readme文档里面主要是关于一些支持的说明。import-into-idea文档告诉如何在自己的编辑器中部署运行代码。 123456789## Steps_Within your locally cloned spring-framework working directory:_1. Generate IDEA metadata with `./gradlew :spring-oxm:compileTestJava cleanIdea idea`2. Import into IDEA as usual3. Set the Project JDK as appropriate4. Add git support5. Code away 按照要求，第一步要执行./gradlew :spring-oxm:compileTestJava cleanIdea idea。在这一步上，第一次耗时比较久，要下载一些依赖。 我在这一步遇到了这个错误 12345678910111213FAILURE: Build failed with an exception.* Where:Script &apos;E:\\project2019\\spring-framework-3.2.13.RELEASE\\spring-oxm\\oxm.gradle&apos; line: 123* What went wrong:Execution failed for task &apos;:spring-oxm:compileTestJava&apos;.&gt; JiBXException in JiBX binding compilation* Try:Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.BUILD FAILED 这个错误，错位的位置为oxm.gradle 123行，JiBX没有绑定的错误，结合源码，把这一段注释掉，就没有什么问题了，可以构建成功。 下一步是导入这个项目，采用gradle的形式进行导入，系统会自动下载其中的依赖，gradle 的模块关系是在根目录下面的settings.gradle中维护的，具体的模块之间的依赖在build.gradle和每个子项目自己的gradle配置文件中有定义。在这里导入会有一些问题。会报如下的错误： 1A problem occurred configuring project &apos;:spring-orm-hibernate4&apos;. 百度了一下，这个问题是由于build.gradle中的merge.into = project(&quot;:spring-****&quot;)引起的，把所有的merge.into都注释了，就不会有问题了。 刷新gradle依赖后，项目导入成功，没有报错了。 运行在spring根目录下新建一个Gradle的module，专门用来测试自己的数据，setting.gradle文件尾部会自动生成include &#39;mytest&#39;，自己新建的项目中有一个私有的配置build.gradle 12345678910111213141516plugins &#123; id &apos;java&apos;&#125;group &apos;org.springframework&apos;version &apos;3.2.13.RELEASE&apos;sourceCompatibility = 1.8repositories &#123; mavenCentral()&#125;dependencies &#123; testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.12&apos;&#125; 这时，如果要使用其他模块的项目，需要在依赖中导入进来，在这个例子中，需要引入spring-beans和spring-core，修改后的依赖为 12345dependencies &#123; compile(project(&quot;:spring-beans&quot;)) compile(project(&quot;:spring-core&quot;)) testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.12&apos;&#125; 建立一个spring配置文件spring-config.xml 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;myTestBean&quot; class=&quot;com.trembear.beans.MyTestBean&quot;/&gt;&lt;/beans&gt; 对应的MyTestBean为： 1234567891011121314151617181920212223242526public class MyTestBean &#123; private String name = &quot;testName&quot;; public MyTestBean(String name) &#123; this.name = name; &#125; public MyTestBean() &#123; &#125; @Override public String toString() &#123; return &quot;MyTestBean&#123;&quot; + &quot;name=&apos;&quot; + name + &apos;\\&apos;&apos; + &apos;&#125;&apos;; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 然后写个Test类 12345678public class AppTest &#123; @Test public void test() &#123; BeanFactory bf = new XmlBeanFactory( new ClassPathResource(&quot;spring-config.xml&quot;)); MyTestBean myTestBean = (MyTestBean) bf.getBean(&quot;myTestBean&quot;); Assert.assertEquals(&quot;testName&quot;,myTestBean.getName()); &#125;&#125; 运行这段代码，可以正常运行，可以按照书中提示一步步的进行源码阅读了。","categories":[{"name":"spring","slug":"spring","permalink":"http://trembear.github.io/categories/spring/"}],"tags":[]},{"title":"shadowsock服务搭建","slug":"shadowSock服务搭建","date":"2019-07-01T04:56:50.000Z","updated":"2019-10-22T01:20:39.888Z","comments":true,"path":"2019/07/01/shadowSock服务搭建/","link":"","permalink":"http://trembear.github.io/2019/07/01/shadowSock服务搭建/","excerpt":"","text":"新的linux主机，现在在上面进行shadowsock搭建。 修改密码由于登录密码是系统给的，所以顺便改一下密码 1234[root@172 ~]# passwd rootChanging password for user root.New password:... 检查Pip和Python是否安装123456[root@172 ~]# pip -Vpip 7.1.0 from /usr/lib/python2.6/site-packages (python 2.6)[root@172 ~]# python -VPython 2.6.6[root@172 ~]# 都安装了，直接进入下一步。 安装package1pip install shadowsocks 可以看到已经安装了这个。但是pip可以更新一下，这里也可以不更新，应该没有什么问题。这里还是按照提示更新一下。 建立配置文件选择任意位置建立一个配置文件，这里是在/etc目录下： 1vi /etc/shadowsocks.json 内容如下 1234567891011&#123; &quot;server&quot;:&quot;服务器 IP 地址&quot;, &quot;server_port&quot;:8388, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;mypassword&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false, &quot;workers&quot;: 1&#125; 各个字段的含义如下： server：服务器 IP (IPv4/IPv6)，注意这也将是服务端监听的 IP 地址server_port：监听的服务器端口local_address：本地监听的 IP 地址local_port：本地端端口password：用来加密的密码timeout：超时时间（秒）method：加密方法，可选择 “bf-cfb”, “aes-256-cfb”, “des-cfb”, “rc4″, 等等。默认是一种不安全的加密，推荐用 “aes-256-cfb”fast_open：true 或 false。如果你的服务器 Linux 内核在3.7+，可以开启 fast_open 以降低延迟。 后台运行1nohup ssserver -c /etc/shadowsocks.json &gt; /dev/null 2&gt;&amp;1 &amp; 检查是否启动1ps -ef | grep ssserve","categories":[{"name":"其他","slug":"其他","permalink":"http://trembear.github.io/categories/其他/"}],"tags":[]},{"title":"gradle和maven的区别","slug":"gradle和maven区别","date":"2019-06-24T07:48:00.000Z","updated":"2019-10-22T01:20:39.887Z","comments":true,"path":"2019/06/24/gradle和maven区别/","link":"","permalink":"http://trembear.github.io/2019/06/24/gradle和maven区别/","excerpt":"","text":"Java世界中主要有三大构建工具：Ant、Maven和Gradle。经过几年的发展，Ant几乎销声匿迹、Maven也日薄西山，而Gradle的发展则如日中天。目前，诸如spring等框架源码的建构工具也都从maven转到gradle上了，说明了掌握gradle是一个必备技能了。 依赖管理 简洁的依赖 相较于maven的引用依赖，gradle显得更加简单，类似于： 1234dependencies &#123; compile &apos;org.hibernate:hibernate-core:3.6.7.Final&apos; testCompile ‘junit:junit:4.+&apos;&#125; 依赖项的scope Maven世界中，一个依赖项有6种scope，分别是complie(默认)、provided、runtime、test、system、import。而grade将其简化为了4种，compile、runtime、testCompile、testRuntime。 如果想实现其他的效果，需要自己编写代码来实现。 动态版本依赖 maven如果不填写具体的版本号，会自动使用最新的；gradle在版本号后面使用+号的方式可以实现动态的版本管理。 依赖冲突解决 解决依赖冲突方面Gradle的实现机制更加明确。使用Maven和Gradle进行依赖管理时都采用的是传递性依赖；而如果多个依赖项指向同一个依赖项的不同版本时就会引起依赖冲突。Gradle在解决依赖冲突方面相对来说比较明确 多模块构建在maven项目中，一般用&lt;modules&gt;标签定义一组子模块，父模块中的配置和属性会自动继承给子模块。 Gradle中的父模块和子模块可以用allprojects和subprojects模块分别定义。对于子模块的定义放置在setttings.gradle中，比Maven更加灵活。例如下例子,在parent的bulid.gradle中有： 123allprojects &#123; task hello &lt;&lt; &#123; task -&gt; println &quot;I&apos;m $task.project.name&quot; &#125;&#125; 执行这个方法会打印出所有父模块和子模块的项目名。 一致的项目结构maven的设计思想为约定大于配置，Gradle也沿用了这一标准的目录结构。如果你在Gradle项目中使用了标准的Maven项目结构的话，那么在Gradle中也无需进行多余的配置,只需在文件中包含apply plugin:’java’,系统会自动识别source、resource、test srouce、 test resource等相应资源。 不过Gradle作为JVM上的构建工具，也同时支持groovy、scala等源代码的构建，甚至支持Java、groovy、scala语言的混合构建。虽然Maven通过一些插件（比如maven-scala-plugin）也能达到相同目的，但配置方面显然Gradle要更优雅一些。 一致的构建模型为了解决Ant中对项目构建活动缺乏标准化的问题，Maven特意设置了标准的项目构建周期，其默认的构建周期如下所示： 12345678910111213141516171819202122232425&lt;phases&gt; &lt;phase&gt;validate&lt;/phase&gt; &lt;phase&gt;initialize&lt;/phase&gt; &lt;phase&gt;generate-sources&lt;/phase&gt; &lt;phase&gt;process-sources&lt;/phase&gt; &lt;phase&gt;generate-resources&lt;/phase&gt; &lt;phase&gt;process-resources&lt;/phase&gt; &lt;phase&gt;compile&lt;/phase&gt; &lt;phase&gt;process-classes&lt;/phase&gt; &lt;phase&gt;generate-test-sources&lt;/phase&gt; &lt;phase&gt;process-test-sources&lt;/phase&gt; &lt;phase&gt;generate-test-resources&lt;/phase&gt; &lt;phase&gt;process-test-resources&lt;/phase&gt; &lt;phase&gt;test-compile&lt;/phase&gt; &lt;phase&gt;process-test-classes&lt;/phase&gt; &lt;phase&gt;test&lt;/phase&gt; &lt;phase&gt;prepare-package&lt;/phase&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;phase&gt;pre-integration-test&lt;/phase&gt; &lt;phase&gt;integration-test&lt;/phase&gt; &lt;phase&gt;post-integration-test&lt;/phase&gt; &lt;phase&gt;verify&lt;/phase&gt; &lt;phase&gt;install&lt;/phase&gt; &lt;phase&gt;deploy&lt;/phase&gt;&lt;/phases&gt; Maven将项目的构建周期限制的太死，你无法在构建周期中添加新的phase，只能将插件绑定到已有的phase上。而且这些phase都是串行的，整个执行下来是一条线，这也限制了Maven的构建效率。 而Gradle在构建模型上则非常灵活。在Gradle世界里可以轻松创建一个task，并随时通过depends语法建立与已有task的依赖关系。甚至对于Java项目的构建来说，Gradle是通过名为java的插件来包含了一个对Java项目的构建周期，这等于Gradle本身直接与项目构建周期是解耦的。 插件机制Maven和Gradle设计时都采用了插件机制。但显然Gradle更胜一筹。主要原因在于Maven是基于XML进行配置。所以其配置语法太受限于XML。即使实现很小的功能都需要设计一个插件，建立其与XML配置的关联。比如想在Maven中执行一条shell命令，其配置如下： 123456789101112131415161718192021222324&lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;drop DB =&gt; db_name&lt;/id&gt; &lt;phase&gt;pre-integration-test&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;exec&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;executable&gt;curl&lt;/executable&gt; &lt;arguments&gt; &lt;argument&gt;-s&lt;/argument&gt; &lt;argument&gt;-S&lt;/argument&gt; &lt;argument&gt;-X&lt;/argument&gt; &lt;argument&gt;DELETE&lt;/argument&gt; &lt;argument&gt;http://$&#123;db.server&#125;:$&#123;db.port&#125;/db_name&lt;/argument&gt; &lt;/arguments&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 而在Gradle中则一切变得非常简单。 123task dropDB(type: Exec) &#123; commandLine ‘curl’,’-s’,’s’,’-x’,’DELETE’,\"http://$&#123;db.server&#125;:&#123;db.port&#125;/db_name\"&#125; 以上的五个方面是gradle和maven最主要的优化特性。 参考于https://www.cnblogs.com/lykbk/p/erwerwerwerwerwerwe.html","categories":[{"name":"工具","slug":"工具","permalink":"http://trembear.github.io/categories/工具/"}],"tags":[{"name":"gradle","slug":"gradle","permalink":"http://trembear.github.io/tags/gradle/"}]},{"title":"ss账号分享","slug":"ss账号分享","date":"2019-06-19T09:56:50.000Z","updated":"2019-11-09T05:15:39.980Z","comments":true,"path":"2019/06/19/ss账号分享/","link":"","permalink":"http://trembear.github.io/2019/06/19/ss账号分享/","excerpt":"","text":"账号1jsx1234567891011&#123;\"server\":\"95.169.24.184\",\"local_address\": \"127.0.0.1\",\"local_port\":1080,\"port_password\":&#123;\"40002\":\"password1\"&#125;,\"timeout\":300,\"method\":\"aes-256-cfb\",\"fast_open\": false&#125; 账号2","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://trembear.github.io/categories/杂谈/"}],"tags":[{"name":"shadowsock","slug":"shadowsock","permalink":"http://trembear.github.io/tags/shadowsock/"}]},{"title":"如何省心的搭建博客","slug":"hello-world","date":"2019-06-19T09:56:50.000Z","updated":"2019-10-22T01:20:39.887Z","comments":true,"path":"2019/06/19/hello-world/","link":"","permalink":"http://trembear.github.io/2019/06/19/hello-world/","excerpt":"","text":"原因之前用的一个博客，使用的是基于java的一个博客系统，挂在bandwagon主机上，现在搬瓦工主机被墙了，导致了一系列的问题，ShadowSock不能用了，ftp也挂了，数据库和其他的一些服务都停止了。所以现在决定不用远程主机了，加之经济紧张，准备将站点直接挂在github page上。github page还是非常给力的，可以在上面挂静态网站，但是为了更省心的写博客，还是有一些东西要思考的。 选择服务器之前用的服务器现在不能用了，转到github上，服务器不需要了，配置流程： 建立一个网站仓库建仓库的时候注意将仓库名设置为.github.io，这样在生成网站时能将此站挂在根目录上。 设置域名可以设置自己的域名，如果没有域名不需要设置，访问的网址就是.github.io 测试在这个仓库更目录写一个index.html,即可通过此网站访问。选择博客平台博客平台有很多，按照网上资料最多的是Hexo。 前置安装npm nodejs由于自己的电脑中已经安装了npm，这一步跳过 npm安装hexo 12345# Create a new post$ hexo new &quot;My New Post&quot;$ hexo server$ hexo generate$ hexo deploy 选择主题进入hexo的帮助页面，里面有一个主题库，里面都是各个热心大佬提供的主题，主题的下载可以从github中下载下来，然后放入自己的themes库中，在config.yml中设置自己的主题，即可。目前这个主题是由https://github.com/yscoder/hexo-theme-indigo.git提供的主题 如何选择省心的图床图床的选择也很关键，之前我用的是shareX，在自己的主机上通过ftp自动上传剪贴板中的图片。现在由于shareX不支持直接向github上传图片，所以采用的是另外一个工具picGo，可以复制图片后，通过快捷键向github中传图片。github中可以先建一个图片库，将此库作为github page 的路由page。设置一个token可以供上传使用，再再picGo中配置即可。 多台电脑编辑发布项目建完后，下载github插件可以通过hexo g -d自动发布到github page中。但是如果要多个客户端编辑源文件，需要将整个项目再存在github中的另外一个源码库中。在多个电脑中同步编辑，每次发布完成后需要提交文件。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://trembear.github.io/categories/杂谈/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://trembear.github.io/tags/hexo/"}]}]}