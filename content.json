{"meta":{"title":"TremBear's Blog","subtitle":"学习弯道超车的技巧!","description":"熊俊伟的博客","author":"trembear","url":"http://trembear.github.io","root":"/"},"pages":[{"title":"tags","date":"2019-06-19T09:56:05.000Z","updated":"2019-10-22T01:20:39.888Z","comments":false,"path":"tags/index.html","permalink":"http://trembear.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-06-19T09:56:50.000Z","updated":"2019-10-22T01:20:39.888Z","comments":false,"path":"categories/index.html","permalink":"http://trembear.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"mybatis-generator 配置详解","slug":"mybatis-generator 配置详解","date":"2019-07-20T09:39:00.000Z","updated":"2019-10-22T01:43:07.409Z","comments":true,"path":"2019/07/20/mybatis-generator 配置详解/","link":"","permalink":"http://trembear.github.io/2019/07/20/mybatis-generator 配置详解/","excerpt":"","text":"概述MyBatis官方提供了逆向工程 mybatis-generator，可以针对数据库表自动生成MyBatis执行所需要的代码（如Mapper.java、Mapper.xml、POJO）。mybatis-generator 有三种用法：命令行、eclipse插件、maven插件。而maven插件的方式比较通用，本文也将概述maven插件的使用方式。 配置形式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"\"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;&lt;!-- 配置生成器 --&gt;&lt;generatorConfiguration&gt;&lt;!-- 可以用于加载配置项或者配置文件，在整个配置文件中就可以使用$&#123;propertyKey&#125;的方式来引用配置项 resource：配置资源加载地址，使用resource，MBG从classpath开始找，比如com/myproject/generatorConfig.properties url：配置资源加载地质，使用URL的方式，比如file:///C:/myfolder/generatorConfig.properties. 注意，两个属性只能选址一个; 另外，如果使用了mybatis-generator-maven-plugin，那么在pom.xml中定义的properties都可以直接在generatorConfig.xml中使用&lt;properties resource=\"\" url=\"\" /&gt; --&gt; &lt;!-- 在MBG工作的时候，需要额外加载的依赖包 location属性指明加载jar/zip包的全路径&lt;classPathEntry location=\"/Program Files/IBM/SQLLIB/java/db2java.zip\" /&gt; --&gt; &lt;!-- context:生成一组对象的环境 id:必选，上下文id，用于在生成错误时提示 defaultModelType:指定生成对象的样式 1，conditional：类似hierarchical； 2，flat：所有内容（主键，blob）等全部生成在一个对象中； 3，hierarchical：主键生成一个XXKey对象(key class)，Blob等单独生成一个对象，其他简单属性在一个对象中(record class) targetRuntime: 1，MyBatis3：默认的值，生成基于MyBatis3.x以上版本的内容，包括XXXBySample； 2，MyBatis3Simple：类似MyBatis3，只是不生成XXXBySample； introspectedColumnImpl：类全限定名，用于扩展MBG--&gt;&lt;context id=\"mysql\" defaultModelType=\"hierarchical\" targetRuntime=\"MyBatis3Simple\" &gt; &lt;!-- 自动识别数据库关键字，默认false，如果设置为true，根据SqlReservedWords中定义的关键字列表； 一般保留默认值，遇到数据库关键字（Java关键字），使用columnOverride覆盖 --&gt; &lt;property name=\"autoDelimitKeywords\" value=\"false\"/&gt; &lt;!-- 生成的Java文件的编码 --&gt; &lt;property name=\"javaFileEncoding\" value=\"UTF-8\"/&gt; &lt;!-- 格式化java代码 --&gt; &lt;property name=\"javaFormatter\" value=\"org.mybatis.generator.api.dom.DefaultJavaFormatter\"/&gt; &lt;!-- 格式化XML代码 --&gt; &lt;property name=\"xmlFormatter\" value=\"org.mybatis.generator.api.dom.DefaultXmlFormatter\"/&gt; &lt;!-- beginningDelimiter和endingDelimiter：指明数据库的用于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是`反引号； --&gt; &lt;property name=\"beginningDelimiter\" value=\"`\"/&gt; &lt;property name=\"endingDelimiter\" value=\"`\"/&gt; &lt;!-- 必须要有的，使用这个配置链接数据库 @TODO:是否可以扩展 --&gt; &lt;jdbcConnection driverClass=\"com.mysql.jdbc.Driver\" connectionURL=\"jdbc:mysql:///pss\" userId=\"root\" password=\"admin\"&gt; &lt;!-- 这里面可以设置property属性，每一个property属性都设置到配置的Driver上 --&gt; &lt;/jdbcConnection&gt; &lt;!-- java类型处理器 用于处理DB中的类型到Java中的类型，默认使用JavaTypeResolverDefaultImpl； 注意一点，默认会先尝试使用Integer，Long，Short等来对应DECIMAL和 NUMERIC数据类型； --&gt; &lt;javaTypeResolver type=\"org.mybatis.generator.internal.types.JavaTypeResolverDefaultImpl\"&gt; &lt;!-- true：使用BigDecimal对应DECIMAL和 NUMERIC数据类型 false：默认, scale&gt;0;length&gt;18：使用BigDecimal; scale=0;length[10,18]：使用Long； scale=0;length[5,9]：使用Integer； scale=0;length&lt;5：使用Short； --&gt; &lt;property name=\"forceBigDecimals\" value=\"false\"/&gt; &lt;/javaTypeResolver&gt; &lt;!-- java模型创建器，是必须要的元素 负责：1，key类（见context的defaultModelType）；2，java类；3，查询类 targetPackage：生成的类要放的包，真实的包受enableSubPackages属性控制； targetProject：目标项目，指定一个存在的目录下，生成的内容会放到指定目录中，如果目录不存在，MBG不会自动建目录 --&gt; &lt;javaModelGenerator targetPackage=\"com._520it.mybatis.domain\" targetProject=\"src/main/java\"&gt; &lt;!-- for MyBatis3/MyBatis3Simple 自动为每一个生成的类创建一个构造方法，构造方法包含了所有的field；而不是使用setter； --&gt; &lt;property name=\"constructorBased\" value=\"false\"/&gt; &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt; &lt;property name=\"enableSubPackages\" value=\"true\"/&gt; &lt;!-- for MyBatis3 / MyBatis3Simple 是否创建一个不可变的类，如果为true， 那么MBG会创建一个没有setter方法的类，取而代之的是类似constructorBased的类 --&gt; &lt;property name=\"immutable\" value=\"false\"/&gt; &lt;!-- 设置一个根对象， 如果设置了这个根对象，那么生成的keyClass或者recordClass会继承这个类；在Table的rootClass属性中可以覆盖该选项 注意：如果在key class或者record class中有root class相同的属性，MBG就不会重新生成这些属性了，包括： 1，属性名相同，类型相同，有相同的getter/setter方法； --&gt; &lt;property name=\"rootClass\" value=\"com._520it.mybatis.domain.BaseDomain\"/&gt; &lt;!-- 设置是否在getter方法中，对String类型字段调用trim()方法 --&gt; &lt;property name=\"trimStrings\" value=\"true\"/&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成SQL map的XML文件生成器， 注意，在Mybatis3之后，我们可以使用mapper.xml文件+Mapper接口（或者不用mapper接口）， 或者只使用Mapper接口+Annotation，所以，如果 javaClientGenerator配置中配置了需要生成XML的话，这个元素就必须配置 targetPackage/targetProject:同javaModelGenerator --&gt; &lt;sqlMapGenerator targetPackage=\"com._520it.mybatis.mapper\" targetProject=\"src/main/resources\"&gt; &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt; &lt;property name=\"enableSubPackages\" value=\"true\"/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 对于mybatis来说，即生成Mapper接口，注意，如果没有配置该元素，那么默认不会生成Mapper接口 targetPackage/targetProject:同javaModelGenerator type：选择怎么生成mapper接口（在MyBatis3/MyBatis3Simple下）： 1，ANNOTATEDMAPPER：会生成使用Mapper接口+Annotation的方式创建（SQL生成在annotation中），不会生成对应的XML； 2，MIXEDMAPPER：使用混合配置，会生成Mapper接口，并适当添加合适的Annotation，但是XML会生成在XML中； 3，XMLMAPPER：会生成Mapper接口，接口完全依赖XML； 注意，如果context是MyBatis3Simple：只支持ANNOTATEDMAPPER和XMLMAPPER --&gt; &lt;javaClientGenerator targetPackage=\"com._520it.mybatis.mapper\" type=\"ANNOTATEDMAPPER\" targetProject=\"src/main/java\"&gt; &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt; &lt;property name=\"enableSubPackages\" value=\"true\"/&gt; &lt;!-- 可以为所有生成的接口添加一个父接口，但是MBG只负责生成，不负责检查 &lt;property name=\"rootInterface\" value=\"\"/&gt; --&gt; &lt;/javaClientGenerator&gt; &lt;!-- 选择一个table来生成相关文件，可以有一个或多个table，必须要有table元素 选择的table会生成一下文件： 1，SQL map文件 2，生成一个主键类； 3，除了BLOB和主键的其他字段的类； 4，包含BLOB的类； 5，一个用户生成动态查询的条件类（selectByExample, deleteByExample），可选； 6，Mapper接口（可选） tableName（必要）：要生成对象的表名； 注意：大小写敏感问题。正常情况下，MBG会自动的去识别数据库标识符的大小写敏感度，在一般情况下，MBG会 根据设置的schema，catalog或tablename去查询数据表，按照下面的流程： 1，如果schema，catalog或tablename中有空格，那么设置的是什么格式，就精确的使用指定的大小写格式去查询； 2，否则，如果数据库的标识符使用大写的，那么MBG自动把表名变成大写再查找； 3，否则，如果数据库的标识符使用小写的，那么MBG自动把表名变成小写再查找； 4，否则，使用指定的大小写格式查询； 另外的，如果在创建表的时候，使用的\"\"把数据库对象规定大小写，就算数据库标识符是使用的大写，在这种情况下也会使用给定的大小写来创建表名； 这个时候，请设置delimitIdentifiers=\"true\"即可保留大小写格式； 可选： 1，schema：数据库的schema； 2，catalog：数据库的catalog； 3，alias：为数据表设置的别名，如果设置了alias，那么生成的所有的SELECT SQL语句中，列名会变成：alias_actualColumnName 4，domainObjectName：生成的domain类的名字，如果不设置，直接使用表名作为domain类的名字；可以设置为somepck.domainName，那么会自动把domainName类再放到somepck包里面； 5，enableInsert（默认true）：指定是否生成insert语句； 6，enableSelectByPrimaryKey（默认true）：指定是否生成按照主键查询对象的语句（就是getById或get）； 7，enableSelectByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询语句； 8，enableUpdateByPrimaryKey（默认true）：指定是否生成按照主键修改对象的语句（即update)； 9，enableDeleteByPrimaryKey（默认true）：指定是否生成按照主键删除对象的语句（即delete）； 10，enableDeleteByExample（默认true）：MyBatis3Simple为false，指定是否生成动态删除语句； 11，enableCountByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询总条数语句（用于分页的总条数查询）； 12，enableUpdateByExample（默认true）：MyBatis3Simple为false，指定是否生成动态修改语句（只修改对象中不为空的属性）； 13，modelType：参考context元素的defaultModelType，相当于覆盖； 14，delimitIdentifiers：参考tableName的解释，注意，默认的delimitIdentifiers是双引号，如果类似MYSQL这样的数据库，使用的是`（反引号，那么还需要设置context的beginningDelimiter和endingDelimiter属性） 15，delimitAllColumns：设置是否所有生成的SQL中的列名都使用标识符引起来。默认为false，delimitIdentifiers参考context的属性 注意，table里面很多参数都是对javaModelGenerator，context等元素的默认属性的一个复写； --&gt; &lt;table tableName=\"userinfo\" &gt; &lt;!-- 参考 javaModelGenerator 的 constructorBased属性--&gt; &lt;property name=\"constructorBased\" value=\"false\"/&gt; &lt;!-- 默认为false，如果设置为true，在生成的SQL中，table名字不会加上catalog或schema； --&gt; &lt;property name=\"ignoreQualifiersAtRuntime\" value=\"false\"/&gt; &lt;!-- 参考 javaModelGenerator 的 immutable 属性 --&gt; &lt;property name=\"immutable\" value=\"false\"/&gt; &lt;!-- 指定是否只生成domain类，如果设置为true，只生成domain类，如果还配置了sqlMapGenerator，那么在mapper XML文件中，只生成resultMap元素 --&gt; &lt;property name=\"modelOnly\" value=\"false\"/&gt; &lt;!-- 参考 javaModelGenerator 的 rootClass 属性 &lt;property name=\"rootClass\" value=\"\"/&gt; --&gt; &lt;!-- 参考javaClientGenerator 的 rootInterface 属性 &lt;property name=\"rootInterface\" value=\"\"/&gt; --&gt; &lt;!-- 如果设置了runtimeCatalog，那么在生成的SQL中，使用该指定的catalog，而不是table元素上的catalog &lt;property name=\"runtimeCatalog\" value=\"\"/&gt; --&gt; &lt;!-- 如果设置了runtimeSchema，那么在生成的SQL中，使用该指定的schema，而不是table元素上的schema &lt;property name=\"runtimeSchema\" value=\"\"/&gt; --&gt; &lt;!-- 如果设置了runtimeTableName，那么在生成的SQL中，使用该指定的tablename，而不是table元素上的tablename &lt;property name=\"runtimeTableName\" value=\"\"/&gt; --&gt; &lt;!-- 注意，该属性只针对MyBatis3Simple有用； 如果选择的runtime是MyBatis3Simple，那么会生成一个SelectAll方法，如果指定了selectAllOrderByClause，那么会在该SQL中添加指定的这个order条件； --&gt; &lt;property name=\"selectAllOrderByClause\" value=\"age desc,username asc\"/&gt; &lt;!-- 如果设置为true，生成的model类会直接使用column本身的名字，而不会再使用驼峰命名方法，比如BORN_DATE，生成的属性名字就是BORN_DATE,而不会是bornDate --&gt; &lt;property name=\"useActualColumnNames\" value=\"false\"/&gt; &lt;!-- generatedKey用于生成生成主键的方法， 如果设置了该元素，MBG会在生成的&lt;insert&gt;元素中生成一条正确的&lt;selectKey&gt;元素，该元素可选 column:主键的列名； sqlStatement：要生成的selectKey语句，有以下可选项： Cloudscape:相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL() DB2 :相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL() DB2_MF :相当于selectKey的SQL为：SELECT IDENTITY_VAL_LOCAL() FROM SYSIBM.SYSDUMMY1 Derby :相当于selectKey的SQL为：VALUES IDENTITY_VAL_LOCAL() HSQLDB :相当于selectKey的SQL为：CALL IDENTITY() Informix :相当于selectKey的SQL为：select dbinfo('sqlca.sqlerrd1') from systables where tabid=1 MySql :相当于selectKey的SQL为：SELECT LAST_INSERT_ID() SqlServer :相当于selectKey的SQL为：SELECT SCOPE_IDENTITY() SYBASE :相当于selectKey的SQL为：SELECT @@IDENTITY JDBC :相当于在生成的insert元素上添加useGeneratedKeys=\"true\"和keyProperty属性 &lt;generatedKey column=\"\" sqlStatement=\"\"/&gt; --&gt; &lt;!-- 该元素会在根据表中列名计算对象属性名之前先重命名列名，非常适合用于表中的列都有公用的前缀字符串的时候， 比如列名为：CUST_ID,CUST_NAME,CUST_EMAIL,CUST_ADDRESS等； 那么就可以设置searchString为\"^CUST_\"，并使用空白替换，那么生成的Customer对象中的属性名称就不是 custId,custName等，而是先被替换为ID,NAME,EMAIL,然后变成属性：id，name，email； 注意，MBG是使用java.util.regex.Matcher.replaceAll来替换searchString和replaceString的， 如果使用了columnOverride元素，该属性无效； &lt;columnRenamingRule searchString=\"\" replaceString=\"\"/&gt; --&gt; &lt;!-- 用来修改表中某个列的属性，MBG会使用修改后的列来生成domain的属性； column:要重新设置的列名； 注意，一个table元素中可以有多个columnOverride元素哈~ --&gt; &lt;columnOverride column=\"username\"&gt; &lt;!-- 使用property属性来指定列要生成的属性名称 --&gt; &lt;property name=\"property\" value=\"userName\"/&gt; &lt;!-- javaType用于指定生成的domain的属性类型，使用类型的全限定名 &lt;property name=\"javaType\" value=\"\"/&gt; --&gt; &lt;!-- jdbcType用于指定该列的JDBC类型 &lt;property name=\"jdbcType\" value=\"\"/&gt; --&gt; &lt;!-- typeHandler 用于指定该列使用到的TypeHandler，如果要指定，配置类型处理器的全限定名 注意，mybatis中，不会生成到mybatis-config.xml中的typeHandler 只会生成类似：where id = #&#123;id,jdbcType=BIGINT,typeHandler=com._520it.mybatis.MyTypeHandler&#125;的参数描述 &lt;property name=\"jdbcType\" value=\"\"/&gt; --&gt; &lt;!-- 参考table元素的delimitAllColumns配置，默认为false &lt;property name=\"delimitedColumnName\" value=\"\"/&gt; --&gt; &lt;/columnOverride&gt; &lt;!-- ignoreColumn设置一个MGB忽略的列，如果设置了改列，那么在生成的domain中，生成的SQL中，都不会有该列出现 column:指定要忽略的列的名字； delimitedColumnName：参考table元素的delimitAllColumns配置，默认为false 注意，一个table元素中可以有多个ignoreColumn元素 &lt;ignoreColumn column=\"deptId\" delimitedColumnName=\"\"/&gt; --&gt; &lt;/table&gt; &lt;/context&gt; &lt;/generatorConfiguration&gt;","categories":[{"name":"spring","slug":"spring","permalink":"http://trembear.github.io/categories/spring/"}],"tags":[]},{"title":"面向服务的架构相关的一些概念","slug":"面向服务架构的概念","date":"2019-07-03T09:39:00.000Z","updated":"2019-10-22T01:40:34.340Z","comments":true,"path":"2019/07/03/面向服务架构的概念/","link":"","permalink":"http://trembear.github.io/2019/07/03/面向服务架构的概念/","excerpt":"","text":"关于软件系统的架构设计，是一个太多人喜欢讨论的问题，尤其是对软件开发不了解的人士来说，总是被各种各样的概念绕来绕去。从更高的层次，能够很清晰的列出这些众多概念的区别，而身在开发一线的我们更多的是对这些概念有一些感性的、朴素的认识。将之内化到自己的工作中去，才能更好的发挥架构的优势。 ##微服务和SOA的区别微服务(MSA)是SOA发展出来的产物，它是一种比较现代化的细粒度的SOA实现方式. ##ESB ESB(enterprise service bus)曾经着实跟随着SOA火了一阵子，从名称就能知道，它的概念借鉴了计算机组成原理中的通信模型——总线，所有需要和外部系统通信的系统，统统接入ESB，岂不是完美地兼容了现有的互相隔离的异构系统，可以利用现有的系统构建一个全新的松耦合的异构的分布式系统。 但，实际使用中，它还是会有很多的缺点，首先就是ESB的本身就很复杂，大大增加了系统的复杂性和可维护性。其次就是由于ESB想要做到所有服务都通过一个通路通信，直接降低了通信速度。 而在现代的微服务中，往往是一个「富终端、瘦通信」（Smart endpoints and dumb pipes），使用轻量级的通信机制，而每个终端（服务）有自己的处理逻辑，它知道它要找的服务在哪里，不需要在通信的链路上做什么事情。 然而，ESB是一个历史产物，用今天的眼光看待它，并且将之当做SOA的一个标签是不合理不公平的。 ##通讯协议如今越来越多的工程开始使用RESTful来作为API的设计的基础，但仅仅几年前还有大把的API使用SOAP、WSDL等基于XML的重量级协议的Web Service。 这点和上文说到的2点其实大同小异，仔细想想，它们都是由于历史原因造成的，同样的，通信协议经过这些年的发展，现在主流的基本上了两种： 文本协议使用最广泛的多是基于HTTP的RESTful规范 轻量级二进制协议Thrift、Protobuf，或者任何自定义的轻量级协议###SOAPsoap用来描述传递信息的格式 ###WSDLWSDL 用来描述如何访问具体的接口 ###UDDIuddi用来管理，分发，查询webService ##实例服务端 客户端 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import java.io.ByteArrayOutputStream;import java.io.DataOutputStream;import java.io.InputStream;import java.net.HttpURLConnection;import java.net.URL;import java.util.HashMap;import java.util.Map;/** * description * * @author Junwei.Xiong * since 2019-07-30 9:56 */public class HttpTest &#123; static String endpointUrl = \"http://localhost:8080/Service/TestServer?wsdl\"; public static Map&lt;String, String&gt; doRequestWS(URL url, String request) &#123; HttpURLConnection connection = null; String rspMsg = \"\"; String rspCode = \"ERROR\"; try &#123; byte[] requestBuf = (byte[]) null; requestBuf = request.getBytes(\"utf-8\"); connection = (HttpURLConnection) url.openConnection(); connection.setDoOutput(true); connection.setDoInput(true); connection.setRequestMethod(\"POST\"); connection.setUseCaches(false); connection.setRequestProperty(\"Content-Type\", \"text/xml\"); connection.connect(); DataOutputStream out = new DataOutputStream( connection.getOutputStream()); out.write(requestBuf); out.flush(); out.close(); if (connection.getResponseCode() != 200) &#123; System.out.println(\"ERROR: \" + connection.getResponseMessage()); &#125; InputStream in = connection.getInputStream(); ByteArrayOutputStream bufOut = new ByteArrayOutputStream(); byte[] readBuf = new byte[100]; while (true) &#123; int ret = in.read(readBuf); if (ret &lt; 0)&#123; break; &#125; bufOut.write(readBuf, 0, ret); &#125; byte[] rspBuf = bufOut.toByteArray(); rspMsg = new String(rspBuf, \"gbk\"); rspCode = connection.getResponseMessage(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; connection = null; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(\"rspCode\", rspCode); map.put(\"rspMsg\", rspMsg); return map; &#125; public static void main(String[] args) throws Exception &#123; StringBuffer sb = new StringBuffer(\"\"); sb.append(\"&lt;?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?&gt;\"); sb.append(\"&lt;soap:Envelope \" + \"xmlns:api='http://service.trembear.com/' \" + \"xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' \" + \"xmlns:xsd='http://www.w3.org/2001/XMLSchema' \" + \"xmlns:soap='http://schemas.xmlsoap.org/soap/envelope/'&gt;\"); sb.append(\"&lt;soap:Body&gt;\"); sb.append(\"&lt;api:helloTest&gt;\"); sb.append(\"&lt;arg0&gt;ls&lt;/arg0&gt;\"); sb.append(\"&lt;/api:helloTest&gt;\"); sb.append(\"&lt;/soap:Body&gt;\"); sb.append(\"&lt;/soap:Envelope&gt;\"); Map&lt;String, String&gt; map = HttpTest.doRequestWS( new URL(endpointUrl), sb.toString()); System.out.println(map); &#125;&#125; 先执行服务端，启动服务，然后执行客户端发起调用。调用的结果如下，可以看到已经有值返回了。 同样的方法在postman中也是能获取到返回值的 在上面的例子中，很好看出，这个传入的参数（以&lt;soap:Envelope开头的）即是soap。 从http://localhost:8080/Service/TestServer?wsdl这个访问浏览器返回的即是wsdl。从wsdl中可以看出这个接口中包含了那些具体的接口，以及需要传入的参数。","categories":[{"name":"spring","slug":"spring","permalink":"http://trembear.github.io/categories/spring/"}],"tags":[]},{"title":"spring源码阅读3-四个默认标签解析","slug":"Spring源码阅读/spring源码阅读3","date":"2019-07-03T09:39:00.000Z","updated":"2019-10-22T01:35:29.719Z","comments":true,"path":"2019/07/03/Spring源码阅读/spring源码阅读3/","link":"","permalink":"http://trembear.github.io/2019/07/03/Spring源码阅读/spring源码阅读3/","excerpt":"","text":"上一篇是关于解析xml文件的内容，在XmlBeanDefinitionReader类中，主要是doLoadBeanDefinitions方法中的解析步骤，这一篇继续跟进注册步骤。 在接下来的过程中，resource被包装为XmlReaderContext，Document转为Element，被documentReader注册到spring中。在具体的doRegisterBeanDefinitions方法中，包含了具体的注册流程parseBeanDefinitions方法。","categories":[{"name":"spring","slug":"spring","permalink":"http://trembear.github.io/categories/spring/"}],"tags":[]},{"title":"spring源码阅读2-项目加载配置文件流程","slug":"Spring源码阅读/spring源码阅读2","date":"2019-07-02T09:39:00.000Z","updated":"2019-10-22T01:33:52.473Z","comments":true,"path":"2019/07/02/Spring源码阅读/spring源码阅读2/","link":"","permalink":"http://trembear.github.io/2019/07/02/Spring源码阅读/spring源码阅读2/","excerpt":"","text":"加载流程针对以下的例子: 12345678public class AppTest &#123; @Test public void test() &#123; BeanFactory bf = new XmlBeanFactory( new ClassPathResource(\"spring-config.xml\")); MyTestBean myTestBean = (MyTestBean) bf.getBean(\"myTestBean\"); Assert.assertEquals(\"testName\",myTestBean.getName()); &#125;&#125; 大致的流程如下： 设置配置文件位置 读取并且校验配置文件 将XML文件转为doc文档 注册doc中的Bean到 第一句话可以拆分为两句： 12Resource resource=new ClassPathResource(\"spring-config.xml\");BeanFactory bf = new XmlBeanFactory(resource); Resource是用于从实际类型的底层资源（例如文件或类路径资源）中抽象的资源描述符的接口。ClassPathResource在加载时，会调用系统的加载classLoader类，加载依赖的class。 123456789public ClassPathResource(String path, ClassLoader classLoader) &#123; Assert.notNull(path, \"Path must not be null\"); String pathToUse = StringUtils.cleanPath(path); if (pathToUse.startsWith(\"/\")) &#123; pathToUse = pathToUse.substring(1); &#125; this.path = pathToUse; this.classLoader = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader());&#125; 拿到resource之后，进入XmlBeanFactory。构造器里有两个主要的方法 123456public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException &#123; //初始化BeanFactory super(parentBeanFactory); //加载resource文件 this.reader.loadBeanDefinitions(resource);&#125; 跟踪super(parentBeanFactory);跟到最后，是 1234567//忽略给定接口的自动装配，如果A中包含了B，在你注入A的时候，会自动注入B，下面是取消自动注入的代码 public AbstractAutowireCapableBeanFactory() &#123; super(); ignoreDependencyInterface(BeanNameAware.class); ignoreDependencyInterface(BeanFactoryAware.class); ignoreDependencyInterface(BeanClassLoaderAware.class);&#125; this.reader.loadBeanDefinitions(resource); 在调用这个方法的时候，会将resource自动封装为EncodedResource，在这之前，this.reader已经初始化 了,这个初始化为后面的获取实体检验加载器，提供了ResourceLoader。 1private final XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(this); 后面在XmlBeanDefinitionReader加载代码为 123456InputStream inputStream = encodedResource.getResource().getInputStream();InputSource inputSource = new InputSource(inputStream);if (encodedResource.getEncoding() != null) &#123; inputSource.setEncoding(encodedResource.getEncoding());&#125;return doLoadBeanDefinitions(inputSource, encodedResource.getResource()); 将文件转为输入流，InputSource不仅包含了InputSource中的内容和编码。继续向下 12345678int doLoadBeanDefinitions(InputSource inputSource, Resource resource)&#123; //读取检验模式（dtd/xsd...） int validationMode = getValidationModeForResource(resource); //将文件流转为Document格式，树状结构 Document doc = this.documentLoader.loadDocument( inputSource, getEntityResolver(), this.errorHandler, validationMode,isNamespaceAware()); return registerBeanDefinitions(doc, resource);&#125; isNamespaceAware()返回XML解析器是否应该支持XML命名空间。 在getEntityResolver()中，在初始化reader的时候，ResourceLoader不为空了，执行的是 12//entityResolver开始为空，resourceLoader为默认的ClassLoaderthis.entityResolver = new ResourceEntityResolver(resourceLoader); ResourceEntityResolver类图如下: ResourceEntityResolver不是spring提供的包，没有继续跟下去了。接着往下看： 12345...private DocumentLoader documentLoader = new DefaultDocumentLoader();...Document doc = this.documentLoader.loadDocument( inputSource, getEntityResolver(), this.errorHandler, validationMode, isNamespaceAware()); 12345678910public Document loadDocument(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception &#123; DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware); if (logger.isDebugEnabled()) &#123; logger.debug(\"Using JAXP provider [\" + factory.getClass().getName() + \"]\"); &#125; DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler); return builder.parse(inputSource);&#125; 具体的如何转换可以继续跟，留着以后看，这里应该还包含了从远程下载dtd,xsd约束文件的代码，这个地方先跳过去。回到XmlBeanDefinitionReader.java中的registerBeanDefinitions(doc, resource)中来， 12345678910public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123; BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); //Environment()从环境中取，与profile字段有关，如果xml中有profile的环境设置，会改变这个值 documentReader.setEnvironment(getEnvironment()); //原有的BeanDefinitionRegistry 仓库 int countBefore = getRegistry().getBeanDefinitionCount(); //加载doc documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); return getRegistry().getBeanDefinitionCount() - countBefore;&#125; createReaderContext(resource)方法获取在bean读取过程中传递的上下文。 registerBeanDefinitions(doc, createReaderContext(resource))跟踪下去，一直到doRegisterBeanDefinitions方法，代码如下： 12345678910111213141516protected void doRegisterBeanDefinitions(Element root) &#123; String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); if (StringUtils.hasText(profileSpec)) &#123; String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); if (!getEnvironment().acceptsProfiles(specifiedProfiles)) &#123; return; &#125; &#125; BeanDefinitionParserDelegate parent = this.delegate; this.delegate = createDelegate(this.readerContext, root, parent); preProcessXml(root); parseBeanDefinitions(root, this.delegate); postProcessXml(root); this.delegate = parent; &#125; 在这段代码中，preProcessXml和postProcessXml两个方法都是空的，给后来的程序进行扩展，貌似在spring-context中，就有对其扩展的例子 一些补充SAX application: JAVA 解析 XML 通常有两种方式:DOM 和SAX。DOM（文档对象模型）是W3C标准，提供了标准的解析方式，但其解析效率一直不尽如人意，这是因为DOM解析XML文档时，把所有内容一次性的装载入内存，并构建一个驻留在内存中的树状结构（节点树）。如果需要解析的XML文档过大，或者我们只对该文档中的一部分感兴趣，这样就会引起性能问题。 EntityResolver: 如果SAX应用程序实现自定义处理外部实体,则必须实现此接口。Sax 解析xml时需要查找对应的dtd定义。EntityResolver申明了一个如何查询dtd的方法。 对于不同的验证模式，spring使用了不同的解析器进行解析。 例如在DelegatingEntityResolver中，加载dtd类型的BeansDtdResolver。加载xsd类型的PluggableEntityResolver，两个的解析模式不一样。 在关于Document是怎么解析这个resolveEntity的具体流程，是在com.sun.org.apache包中实现的，大概的流程如下：","categories":[{"name":"spring","slug":"spring","permalink":"http://trembear.github.io/categories/spring/"}],"tags":[]},{"title":"spring源码阅读1-项目的搭建与导入","slug":"Spring源码阅读/spring源码阅读1","date":"2019-07-01T09:39:00.000Z","updated":"2019-10-22T01:20:39.887Z","comments":true,"path":"2019/07/01/Spring源码阅读/spring源码阅读1/","link":"","permalink":"http://trembear.github.io/2019/07/01/Spring源码阅读/spring源码阅读1/","excerpt":"","text":"spring项目下载源码对应的书籍为《spring源码深度解析》，由于出书也有一段时间，为了便于对照着学习，所以准备下载的源码为3.2.x版本，下载地址为：https://github.com/spring-projects/spring-framework/tree/3.2.x。 部署现在github上的spring项目都是由gradle部署的，所以自己电脑需要提前安装gradle工具，类似于maven，配置好环境后，可以让其更方便的执行。 下载完成后，可以看到项目根目录中有一个readme.md和import-into-idea.md两个文件。readme文档里面主要是关于一些支持的说明。import-into-idea文档告诉如何在自己的编辑器中部署运行代码。 123456789## Steps_Within your locally cloned spring-framework working directory:_1. Generate IDEA metadata with `./gradlew :spring-oxm:compileTestJava cleanIdea idea`2. Import into IDEA as usual3. Set the Project JDK as appropriate4. Add git support5. Code away 按照要求，第一步要执行./gradlew :spring-oxm:compileTestJava cleanIdea idea。在这一步上，第一次耗时比较久，要下载一些依赖。 我在这一步遇到了这个错误 12345678910111213FAILURE: Build failed with an exception.* Where:Script &apos;E:\\project2019\\spring-framework-3.2.13.RELEASE\\spring-oxm\\oxm.gradle&apos; line: 123* What went wrong:Execution failed for task &apos;:spring-oxm:compileTestJava&apos;.&gt; JiBXException in JiBX binding compilation* Try:Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.BUILD FAILED 这个错误，错位的位置为oxm.gradle 123行，JiBX没有绑定的错误，结合源码，把这一段注释掉，就没有什么问题了，可以构建成功。 下一步是导入这个项目，采用gradle的形式进行导入，系统会自动下载其中的依赖，gradle 的模块关系是在根目录下面的settings.gradle中维护的，具体的模块之间的依赖在build.gradle和每个子项目自己的gradle配置文件中有定义。在这里导入会有一些问题。会报如下的错误： 1A problem occurred configuring project &apos;:spring-orm-hibernate4&apos;. 百度了一下，这个问题是由于build.gradle中的merge.into = project(&quot;:spring-****&quot;)引起的，把所有的merge.into都注释了，就不会有问题了。 刷新gradle依赖后，项目导入成功，没有报错了。 运行在spring根目录下新建一个Gradle的module，专门用来测试自己的数据，setting.gradle文件尾部会自动生成include &#39;mytest&#39;，自己新建的项目中有一个私有的配置build.gradle 12345678910111213141516plugins &#123; id &apos;java&apos;&#125;group &apos;org.springframework&apos;version &apos;3.2.13.RELEASE&apos;sourceCompatibility = 1.8repositories &#123; mavenCentral()&#125;dependencies &#123; testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.12&apos;&#125; 这时，如果要使用其他模块的项目，需要在依赖中导入进来，在这个例子中，需要引入spring-beans和spring-core，修改后的依赖为 12345dependencies &#123; compile(project(&quot;:spring-beans&quot;)) compile(project(&quot;:spring-core&quot;)) testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.12&apos;&#125; 建立一个spring配置文件spring-config.xml 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;myTestBean&quot; class=&quot;com.trembear.beans.MyTestBean&quot;/&gt;&lt;/beans&gt; 对应的MyTestBean为： 1234567891011121314151617181920212223242526public class MyTestBean &#123; private String name = &quot;testName&quot;; public MyTestBean(String name) &#123; this.name = name; &#125; public MyTestBean() &#123; &#125; @Override public String toString() &#123; return &quot;MyTestBean&#123;&quot; + &quot;name=&apos;&quot; + name + &apos;\\&apos;&apos; + &apos;&#125;&apos;; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 然后写个Test类 12345678public class AppTest &#123; @Test public void test() &#123; BeanFactory bf = new XmlBeanFactory( new ClassPathResource(&quot;spring-config.xml&quot;)); MyTestBean myTestBean = (MyTestBean) bf.getBean(&quot;myTestBean&quot;); Assert.assertEquals(&quot;testName&quot;,myTestBean.getName()); &#125;&#125; 运行这段代码，可以正常运行，可以按照书中提示一步步的进行源码阅读了。","categories":[{"name":"spring","slug":"spring","permalink":"http://trembear.github.io/categories/spring/"}],"tags":[]},{"title":"shadowsock服务搭建","slug":"shadowSock服务搭建","date":"2019-07-01T04:56:50.000Z","updated":"2019-10-22T01:20:39.888Z","comments":true,"path":"2019/07/01/shadowSock服务搭建/","link":"","permalink":"http://trembear.github.io/2019/07/01/shadowSock服务搭建/","excerpt":"","text":"新的linux主机，现在在上面进行shadowsock搭建。 修改密码由于登录密码是系统给的，所以顺便改一下密码 1234[root@172 ~]# passwd rootChanging password for user root.New password:... 检查Pip和Python是否安装123456[root@172 ~]# pip -Vpip 7.1.0 from /usr/lib/python2.6/site-packages (python 2.6)[root@172 ~]# python -VPython 2.6.6[root@172 ~]# 都安装了，直接进入下一步。 安装package1pip install shadowsocks 可以看到已经安装了这个。但是pip可以更新一下，这里也可以不更新，应该没有什么问题。这里还是按照提示更新一下。 建立配置文件选择任意位置建立一个配置文件，这里是在/etc目录下： 1vi /etc/shadowsocks.json 内容如下 1234567891011&#123; &quot;server&quot;:&quot;服务器 IP 地址&quot;, &quot;server_port&quot;:8388, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;mypassword&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false, &quot;workers&quot;: 1&#125; 各个字段的含义如下： server：服务器 IP (IPv4/IPv6)，注意这也将是服务端监听的 IP 地址server_port：监听的服务器端口local_address：本地监听的 IP 地址local_port：本地端端口password：用来加密的密码timeout：超时时间（秒）method：加密方法，可选择 “bf-cfb”, “aes-256-cfb”, “des-cfb”, “rc4″, 等等。默认是一种不安全的加密，推荐用 “aes-256-cfb”fast_open：true 或 false。如果你的服务器 Linux 内核在3.7+，可以开启 fast_open 以降低延迟。 后台运行1nohup ssserver -c /etc/shadowsocks.json &gt; /dev/null 2&gt;&amp;1 &amp; 检查是否启动1ps -ef | grep ssserve","categories":[{"name":"其他","slug":"其他","permalink":"http://trembear.github.io/categories/其他/"}],"tags":[]},{"title":"gradle和maven的区别","slug":"gradle和maven区别","date":"2019-06-24T07:48:00.000Z","updated":"2019-10-22T01:20:39.887Z","comments":true,"path":"2019/06/24/gradle和maven区别/","link":"","permalink":"http://trembear.github.io/2019/06/24/gradle和maven区别/","excerpt":"","text":"Java世界中主要有三大构建工具：Ant、Maven和Gradle。经过几年的发展，Ant几乎销声匿迹、Maven也日薄西山，而Gradle的发展则如日中天。目前，诸如spring等框架源码的建构工具也都从maven转到gradle上了，说明了掌握gradle是一个必备技能了。 依赖管理 简洁的依赖 相较于maven的引用依赖，gradle显得更加简单，类似于： 1234dependencies &#123; compile &apos;org.hibernate:hibernate-core:3.6.7.Final&apos; testCompile ‘junit:junit:4.+&apos;&#125; 依赖项的scope Maven世界中，一个依赖项有6种scope，分别是complie(默认)、provided、runtime、test、system、import。而grade将其简化为了4种，compile、runtime、testCompile、testRuntime。 如果想实现其他的效果，需要自己编写代码来实现。 动态版本依赖 maven如果不填写具体的版本号，会自动使用最新的；gradle在版本号后面使用+号的方式可以实现动态的版本管理。 依赖冲突解决 解决依赖冲突方面Gradle的实现机制更加明确。使用Maven和Gradle进行依赖管理时都采用的是传递性依赖；而如果多个依赖项指向同一个依赖项的不同版本时就会引起依赖冲突。Gradle在解决依赖冲突方面相对来说比较明确 多模块构建在maven项目中，一般用&lt;modules&gt;标签定义一组子模块，父模块中的配置和属性会自动继承给子模块。 Gradle中的父模块和子模块可以用allprojects和subprojects模块分别定义。对于子模块的定义放置在setttings.gradle中，比Maven更加灵活。例如下例子,在parent的bulid.gradle中有： 123allprojects &#123; task hello &lt;&lt; &#123; task -&gt; println &quot;I&apos;m $task.project.name&quot; &#125;&#125; 执行这个方法会打印出所有父模块和子模块的项目名。 一致的项目结构maven的设计思想为约定大于配置，Gradle也沿用了这一标准的目录结构。如果你在Gradle项目中使用了标准的Maven项目结构的话，那么在Gradle中也无需进行多余的配置,只需在文件中包含apply plugin:’java’,系统会自动识别source、resource、test srouce、 test resource等相应资源。 不过Gradle作为JVM上的构建工具，也同时支持groovy、scala等源代码的构建，甚至支持Java、groovy、scala语言的混合构建。虽然Maven通过一些插件（比如maven-scala-plugin）也能达到相同目的，但配置方面显然Gradle要更优雅一些。 一致的构建模型为了解决Ant中对项目构建活动缺乏标准化的问题，Maven特意设置了标准的项目构建周期，其默认的构建周期如下所示： 12345678910111213141516171819202122232425&lt;phases&gt; &lt;phase&gt;validate&lt;/phase&gt; &lt;phase&gt;initialize&lt;/phase&gt; &lt;phase&gt;generate-sources&lt;/phase&gt; &lt;phase&gt;process-sources&lt;/phase&gt; &lt;phase&gt;generate-resources&lt;/phase&gt; &lt;phase&gt;process-resources&lt;/phase&gt; &lt;phase&gt;compile&lt;/phase&gt; &lt;phase&gt;process-classes&lt;/phase&gt; &lt;phase&gt;generate-test-sources&lt;/phase&gt; &lt;phase&gt;process-test-sources&lt;/phase&gt; &lt;phase&gt;generate-test-resources&lt;/phase&gt; &lt;phase&gt;process-test-resources&lt;/phase&gt; &lt;phase&gt;test-compile&lt;/phase&gt; &lt;phase&gt;process-test-classes&lt;/phase&gt; &lt;phase&gt;test&lt;/phase&gt; &lt;phase&gt;prepare-package&lt;/phase&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;phase&gt;pre-integration-test&lt;/phase&gt; &lt;phase&gt;integration-test&lt;/phase&gt; &lt;phase&gt;post-integration-test&lt;/phase&gt; &lt;phase&gt;verify&lt;/phase&gt; &lt;phase&gt;install&lt;/phase&gt; &lt;phase&gt;deploy&lt;/phase&gt;&lt;/phases&gt; Maven将项目的构建周期限制的太死，你无法在构建周期中添加新的phase，只能将插件绑定到已有的phase上。而且这些phase都是串行的，整个执行下来是一条线，这也限制了Maven的构建效率。 而Gradle在构建模型上则非常灵活。在Gradle世界里可以轻松创建一个task，并随时通过depends语法建立与已有task的依赖关系。甚至对于Java项目的构建来说，Gradle是通过名为java的插件来包含了一个对Java项目的构建周期，这等于Gradle本身直接与项目构建周期是解耦的。 插件机制Maven和Gradle设计时都采用了插件机制。但显然Gradle更胜一筹。主要原因在于Maven是基于XML进行配置。所以其配置语法太受限于XML。即使实现很小的功能都需要设计一个插件，建立其与XML配置的关联。比如想在Maven中执行一条shell命令，其配置如下： 123456789101112131415161718192021222324&lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;drop DB =&gt; db_name&lt;/id&gt; &lt;phase&gt;pre-integration-test&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;exec&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;executable&gt;curl&lt;/executable&gt; &lt;arguments&gt; &lt;argument&gt;-s&lt;/argument&gt; &lt;argument&gt;-S&lt;/argument&gt; &lt;argument&gt;-X&lt;/argument&gt; &lt;argument&gt;DELETE&lt;/argument&gt; &lt;argument&gt;http://$&#123;db.server&#125;:$&#123;db.port&#125;/db_name&lt;/argument&gt; &lt;/arguments&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 而在Gradle中则一切变得非常简单。 123task dropDB(type: Exec) &#123; commandLine ‘curl’,’-s’,’s’,’-x’,’DELETE’,\"http://$&#123;db.server&#125;:&#123;db.port&#125;/db_name\"&#125; 以上的五个方面是gradle和maven最主要的优化特性。 参考于https://www.cnblogs.com/lykbk/p/erwerwerwerwerwerwe.html","categories":[{"name":"工具","slug":"工具","permalink":"http://trembear.github.io/categories/工具/"}],"tags":[{"name":"gradle","slug":"gradle","permalink":"http://trembear.github.io/tags/gradle/"}]},{"title":"如何省心的搭建博客","slug":"hello-world","date":"2019-06-19T09:56:50.000Z","updated":"2019-10-22T01:20:39.887Z","comments":true,"path":"2019/06/19/hello-world/","link":"","permalink":"http://trembear.github.io/2019/06/19/hello-world/","excerpt":"","text":"原因之前用的一个博客，使用的是基于java的一个博客系统，挂在bandwagon主机上，现在搬瓦工主机被墙了，导致了一系列的问题，ShadowSock不能用了，ftp也挂了，数据库和其他的一些服务都停止了。所以现在决定不用远程主机了，加之经济紧张，准备将站点直接挂在github page上。github page还是非常给力的，可以在上面挂静态网站，但是为了更省心的写博客，还是有一些东西要思考的。 选择服务器之前用的服务器现在不能用了，转到github上，服务器不需要了，配置流程： 建立一个网站仓库建仓库的时候注意将仓库名设置为.github.io，这样在生成网站时能将此站挂在根目录上。 设置域名可以设置自己的域名，如果没有域名不需要设置，访问的网址就是.github.io 测试在这个仓库更目录写一个index.html,即可通过此网站访问。选择博客平台博客平台有很多，按照网上资料最多的是Hexo。 前置安装npm nodejs由于自己的电脑中已经安装了npm，这一步跳过 npm安装hexo 12345# Create a new post$ hexo new &quot;My New Post&quot;$ hexo server$ hexo generate$ hexo deploy 选择主题进入hexo的帮助页面，里面有一个主题库，里面都是各个热心大佬提供的主题，主题的下载可以从github中下载下来，然后放入自己的themes库中，在config.yml中设置自己的主题，即可。目前这个主题是由https://github.com/yscoder/hexo-theme-indigo.git提供的主题 如何选择省心的图床图床的选择也很关键，之前我用的是shareX，在自己的主机上通过ftp自动上传剪贴板中的图片。现在由于shareX不支持直接向github上传图片，所以采用的是另外一个工具picGo，可以复制图片后，通过快捷键向github中传图片。github中可以先建一个图片库，将此库作为github page 的路由page。设置一个token可以供上传使用，再再picGo中配置即可。 多台电脑编辑发布项目建完后，下载github插件可以通过hexo g -d自动发布到github page中。但是如果要多个客户端编辑源文件，需要将整个项目再存在github中的另外一个源码库中。在多个电脑中同步编辑，每次发布完成后需要提交文件。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://trembear.github.io/categories/杂谈/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://trembear.github.io/tags/hexo/"}]}]}