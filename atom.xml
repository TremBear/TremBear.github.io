<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TremBear&#39;s Blog</title>
  
  <subtitle>学习弯道超车的技巧!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://trembear.github.io/"/>
  <updated>2019-12-03T07:57:18.142Z</updated>
  <id>http://trembear.github.io/</id>
  
  <author>
    <name>trembear</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多线程与锁</title>
    <link href="http://trembear.github.io/2019/11/15/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%94%81/"/>
    <id>http://trembear.github.io/2019/11/15/java/多线程和锁/</id>
    <published>2019-11-15T09:18:07.000Z</published>
    <updated>2019-12-03T07:57:18.142Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程创建形式"><a href="#线程创建形式" class="headerlink" title="线程创建形式"></a>线程创建形式</h2><ol><li>继承ThreadLocal</li><li>实现Runnable</li><li>实现Callable：有返回值的任务，用Future接受返回值</li><li>使用线程池ExecutorService实现  <ol><li>newCachedThreadPool 不定长线程池</li><li>newFixedThreadPool 定长线程池</li><li>newScheduledThreadPool 定时线程池</li><li>newSingleThreadExecutor 串行线程池</li></ol></li></ol><h2 id="sleep-和-wait"><a href="#sleep-和-wait" class="headerlink" title="sleep() 和 wait()"></a>sleep() 和 wait()</h2><h2 id="Synchronized使用方法"><a href="#Synchronized使用方法" class="headerlink" title="Synchronized使用方法"></a>Synchronized使用方法</h2><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。JDK中提供的ThreadLocal类正是为了解决这样的问题。 ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</p><h3 id="ThreadLocal-内存泄露问题"><a href="#ThreadLocal-内存泄露问题" class="headerlink" title="ThreadLocal 内存泄露问题:"></a>ThreadLocal 内存泄露问题:</h3><p>ThreadLocal,中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会<code>key</code>会被清理掉，而<code>value</code>不会被清理掉。<br>在调用set()、get()、remove() 方法的时候，会清理掉<code>key</code>为<code>null</code>的记录。</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。</p><h3 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h3><p>每次修改一个数据，一般是在数据表中加上一个数据版本号version字段。操作示意如下：</p><ol><li>数据库里有金额100，version=1</li><li>A读取金额100，修改金额为50，修改version=2</li><li>B读取金额为100，修改金额为60，修改version=2</li><li>A提交到库，这时有一个判断，如果当前version&gt;库里的version，那么通过，A可以通过</li><li>由于A修改了库version=2，B的version没有大于2，被驳回，不可提交</li></ol><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>CAS 适合简单对象的操作，比如布尔值、整型值等。<br>内部保持着一个volatile修饰的long变量，volatile保证了long的值更新后，其他线程能立即获得最新的值。<br>自旋锁，比较交换算法，需要读写的内存值V，进行比较的值A，拟写入的值B</p><ol><li>如果A取到的Value为1,要对value进行加1操作，设置期望值为2</li><li>如果B取到的Value为1，要对value进行+1，设置期望值为2</li><li>A判断value+1为2，与期望值相等，那么修改Value为2</li><li>B判断实际的V+B=3,与期望的2不相等，那么返回失败，继续第二步，这时读出的Value为2,循环一次。</li></ol><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。<br>Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><h2 id="不可重入锁"><a href="#不可重入锁" class="headerlink" title="不可重入锁"></a>不可重入锁</h2><h2 id="AQS实现原理"><a href="#AQS实现原理" class="headerlink" title="AQS实现原理"></a>AQS实现原理</h2><h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h2 id="分布式锁的redis实现方式"><a href="#分布式锁的redis实现方式" class="headerlink" title="分布式锁的redis实现方式"></a>分布式锁的redis实现方式</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;线程创建形式&quot;&gt;&lt;a href=&quot;#线程创建形式&quot; class=&quot;headerlink&quot; title=&quot;线程创建形式&quot;&gt;&lt;/a&gt;线程创建形式&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;继承ThreadLocal&lt;/li&gt;
&lt;li&gt;实现Runnable&lt;/li&gt;
&lt;li&gt;实现Cal
      
    
    </summary>
    
      <category term="spring" scheme="http://trembear.github.io/categories/spring/"/>
    
    
  </entry>
  
  <entry>
    <title>如何设计一款发号器</title>
    <link href="http://trembear.github.io/2019/11/15/java/%E8%AE%BE%E8%AE%A1%E5%8F%91%E5%8F%B7%E5%99%A8/"/>
    <id>http://trembear.github.io/2019/11/15/java/设计发号器/</id>
    <published>2019-11-15T09:17:27.000Z</published>
    <updated>2019-12-03T07:55:46.091Z</updated>
    
    <content type="html"><![CDATA[<p>在单机环境中，遇到生成不重复Id的问题时，我们一般使用数据库自增主键的形式或者UUID的形式，在分布式系统中，我们使用的不止是一台数据库，使用UUID又会遇到内存消耗过大的情况，并且uuid是没有顺序的，导致B+ tree做索引时有太多的随机操作，性能下降。为了解决这个问题，单独抽出ID生成器模块进行不重复的递增ID生成。</p><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><ol><li>全局唯一</li><li>基本有序</li><li>高性能</li><li>高可用</li><li>可灵活配置（多种接入方案）</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>该ID二进制总共有64位，具体如下：  </p><table><thead><tr><th>版本</th><th>类型</th><th>生成方式</th><th>秒级时间</th><th>序列号</th><th>机器ID</th></tr></thead><tbody><tr><td>63</td><td>62</td><td>60-61</td><td>30-59</td><td>10-29</td><td>0-10</td></tr></tbody></table><p>系统采用多模块的结构，分为：  </p><ol><li>intf层：接口模块</li><li>service层：提供服务的模块 （引入intf依赖）</li><li>rest层： 对外提供Rest接口 （引入service依赖）  </li></ol><p>系统结构为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.swapassn.com/picRepo/img/20191203151046.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>各个部分的描述：</p><ol><li><p>Id 类为组成ID的各个字段的结构</p></li><li><p>IdService接口提供了一个生成号码的方法</p></li><li><p>AbstractIdService是一个抽象类，实现了genId的方法，组装类型，机器ID等六个子字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">genId</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Id id = <span class="keyword">new</span> Id();</span><br><span class="line">    id.setMachine(machineId);</span><br><span class="line">    id.setGenMethod(genMethod);</span><br><span class="line">    id.setType(idType.value());</span><br><span class="line">    id.setVersion(version);</span><br><span class="line">    <span class="comment">//由子类生成Id的序列号和验证码</span></span><br><span class="line">    populateId(id);</span><br><span class="line">    <span class="comment">//转化id</span></span><br><span class="line">    <span class="keyword">long</span> ret = convert(id, <span class="keyword">this</span>.idMate);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">populateId</span><span class="params">(Id id)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>子类的初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdServiceImpl</span> <span class="keyword">extends</span> <span class="title">AbstractIdService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个类用来生成序列号</span></span><br><span class="line">    IdPopulator idPopulator;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IdServiceImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//父类初始化，设置模式为 秒级 生成，并且设置各个字段所占的字节数</span></span><br><span class="line">        <span class="keyword">super</span>.init();</span><br><span class="line">        initPopulator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initPopulator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        idPopulator=<span class="keyword">new</span> SyncIdPopulator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateId</span><span class="params">(Id id)</span> </span>&#123;</span><br><span class="line">        idPopulator.populateId(id, <span class="keyword">this</span>.idMate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>父类的初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractIdService</span> <span class="keyword">implements</span> <span class="title">IdService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> machineId=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> genMethod=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> version=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">protected</span> IdType idType;</span><br><span class="line">    <span class="keyword">protected</span> IdMate idMate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//设置为类型为秒级</span></span><br><span class="line">        idType=IdType.SECONDS;</span><br><span class="line">        <span class="comment">//设置各个字段所占的位数</span></span><br><span class="line">        idMate= <span class="keyword">new</span> IdMate((<span class="keyword">byte</span>) <span class="number">10</span>, (<span class="keyword">byte</span>) <span class="number">20</span>, (<span class="keyword">byte</span>) <span class="number">30</span>, (<span class="keyword">byte</span>) <span class="number">2</span>, (<span class="keyword">byte</span>) <span class="number">1</span>, (<span class="keyword">byte</span>) <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体生成的时间和序列号设计，逻辑如下，通过锁来控制并发问题，这个地方的逻辑可以通过Lock或者自旋锁来进行设计，同一时间里面的序列号地递增，过了当前时间后的时间改变，同时序列号置为0：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncIdPopulator</span> <span class="keyword">implements</span> <span class="title">IdPopulator</span> </span>&#123;</span><br><span class="line">    <span class="comment">//序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequence=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//时间戳</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastTimestamp=-<span class="number">1</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">populateId</span><span class="params">(Id id, IdMate idMate)</span> </span>&#123;</span><br><span class="line">        Timer timer=<span class="keyword">new</span> SimpleTimer();</span><br><span class="line">        <span class="keyword">long</span> timestamp= timer.genTime();</span><br><span class="line">        <span class="keyword">if</span>(timestamp==lastTimestamp)&#123;</span><br><span class="line">            sequence++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            lastTimestamp=timestamp;</span><br><span class="line">            sequence=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        id.setSeq(sequence);</span><br><span class="line">        id.setTime(timestamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>额外的时间类（SimpleTimer）:时间类用于生成时间的long类型的数值</p></li><li><p>Abstract类中的拼接，按照更合理的做法，应该是通过IdType类型作判断，然后由工厂类生成指定的拼接方法，这里只是做一个示范：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">doConvert</span><span class="params">(Id id, IdMate idMeta)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">       ret |= id.getMachine();</span><br><span class="line">   </span><br><span class="line">       ret |= id.getSeq() &lt;&lt; idMeta.getSeqBitsStartPos();</span><br><span class="line">   </span><br><span class="line">       ret |= id.getTime() &lt;&lt; idMeta.getTimeBitsStartPos();</span><br><span class="line">   </span><br><span class="line">       ret |= id.getGenMethod() &lt;&lt; idMeta.getGenMethodBitsStartPos();</span><br><span class="line">   </span><br><span class="line">       ret |= id.getType() &lt;&lt; idMeta.getTypeBitsStartPos();</span><br><span class="line">   </span><br><span class="line">       ret |= id.getVersion() &lt;&lt; idMeta.getVersionBitsStartPos();</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NtTest</span> </span>&#123;</span><br><span class="line">       <span class="meta">@Test</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">           IdServiceImpl idService=<span class="keyword">new</span> IdServiceImpl();</span><br><span class="line">           System.out.println(idService.genId());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li>时间的生成与压缩<ol><li>如果并发太大，并且超过了同一秒中的所有的最大序列值，那么可以让其自旋等待下一秒</li><li>压缩：通过ID中类型来确定时间单位，设置一个基准值，用当前值减去基准值，除以一个位数，进行压缩</li></ol></li><li>机器Id的生成<ol><li>通过配置，配置每一台机器上不同的机器ID</li><li>通过IP来分配一个不同的Id</li><li>通过数据库来分配</li><li>通过zookeeper来分配一个</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在单机环境中，遇到生成不重复Id的问题时，我们一般使用数据库自增主键的形式或者UUID的形式，在分布式系统中，我们使用的不止是一台数据库，使用UUID又会遇到内存消耗过大的情况，并且uuid是没有顺序的，导致B+ tree做索引时有太多的随机操作，性能下降。为了解决这个问题
      
    
    </summary>
    
      <category term="spring" scheme="http://trembear.github.io/categories/spring/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库优化</title>
    <link href="http://trembear.github.io/2019/11/15/java/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    <id>http://trembear.github.io/2019/11/15/java/数据库优化/</id>
    <published>2019-11-15T09:17:27.000Z</published>
    <updated>2019-11-15T09:34:25.977Z</updated>
    
    <content type="html"><![CDATA[<h2 id="索引失效问题"><a href="#索引失效问题" class="headerlink" title="索引失效问题"></a>索引失效问题</h2><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h2 id="MyCat"><a href="#MyCat" class="headerlink" title="MyCat"></a>MyCat</h2><h2 id="Sharding-JDBC"><a href="#Sharding-JDBC" class="headerlink" title="Sharding-JDBC"></a>Sharding-JDBC</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;索引失效问题&quot;&gt;&lt;a href=&quot;#索引失效问题&quot; class=&quot;headerlink&quot; title=&quot;索引失效问题&quot;&gt;&lt;/a&gt;索引失效问题&lt;/h2&gt;&lt;h2 id=&quot;分库分表&quot;&gt;&lt;a href=&quot;#分库分表&quot; class=&quot;headerlink&quot; title=&quot;分
      
    
    </summary>
    
      <category term="spring" scheme="http://trembear.github.io/categories/spring/"/>
    
    
  </entry>
  
  <entry>
    <title>java易错知识点</title>
    <link href="http://trembear.github.io/2019/11/15/java/java%E6%98%93%E9%94%99%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://trembear.github.io/2019/11/15/java/java易错知识点/</id>
    <published>2019-11-15T06:58:06.000Z</published>
    <updated>2019-12-03T06:33:40.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM内存区域"><a href="#JVM内存区域" class="headerlink" title="JVM内存区域"></a>JVM内存区域</h2><ol><li>方法区(线程共享):储被 JVM 加载的类信息、 常量、 静态变量、 即时编译器编译后的代码等数据<br> a. 运行时常量池： 运行期间也可能将新的常量放入池中（常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享）</li><li>堆（线程共享）：创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域。</li><li>虚拟机栈（线程私有）: 方法执行的内存模型，每个方法执行的时候都会创建栈帧，方法结束出栈。</li><li>本地方法区（线程私有）：JVM调用外部的一些栈</li><li>程序计数器（线程私有）：当前线程的指示器</li></ol><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><ol><li>阻塞IO</li><li>非阻塞IO：客户线程轮询，返回错误结果后继续发起请求。</li><li>多路复用IO ：内核轮询，一个线程管理多个来源的IO</li><li>NIO：Java NIO 实际上就是多路复用IO，创建多个socket。内核不断轮询各个socket</li><li>信号驱动IO：发起IO的时候，给socket一个函数，就绪后发送信号给用户线程</li><li>异步IO：应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</li></ol><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>双亲委派模式：  </p><ol><li>自底向上检查是否类是否被夹在</li><li>自顶向下尝试加载类<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.swapassn.com/picRepo/img/20191115161234.png" alt title>                </div>                <div class="image-caption"></div>            </figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JVM内存区域&quot;&gt;&lt;a href=&quot;#JVM内存区域&quot; class=&quot;headerlink&quot; title=&quot;JVM内存区域&quot;&gt;&lt;/a&gt;JVM内存区域&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;方法区(线程共享):储被 JVM 加载的类信息、 常量、 静态变量、 即时编译器编译后的
      
    
    </summary>
    
      <category term="java基础" scheme="http://trembear.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring相关知识</title>
    <link href="http://trembear.github.io/2019/11/15/java/Spring%E5%BA%94%E7%94%A8%E7%9B%B8%E5%85%B3%E7%9A%84%E7%9F%A5%E8%AF%86/"/>
    <id>http://trembear.github.io/2019/11/15/java/Spring应用相关的知识/</id>
    <published>2019-11-15T06:58:06.000Z</published>
    <updated>2019-11-15T09:28:25.216Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="spring" scheme="http://trembear.github.io/categories/spring/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="http://trembear.github.io/2019/11/15/java/Redis/"/>
    <id>http://trembear.github.io/2019/11/15/java/Redis/</id>
    <published>2019-11-15T06:58:06.000Z</published>
    <updated>2019-11-15T09:31:51.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h2><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><h2 id="Redis实现排行"><a href="#Redis实现排行" class="headerlink" title="Redis实现排行"></a>Redis实现排行</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;缓存一致性&quot;&gt;&lt;a href=&quot;#缓存一致性&quot; class=&quot;headerlink&quot; title=&quot;缓存一致性&quot;&gt;&lt;/a&gt;缓存一致性&lt;/h2&gt;&lt;h2 id=&quot;集群&quot;&gt;&lt;a href=&quot;#集群&quot; class=&quot;headerlink&quot; title=&quot;集群&quot;&gt;&lt;/a&gt;集
      
    
    </summary>
    
      <category term="spring" scheme="http://trembear.github.io/categories/spring/"/>
    
    
  </entry>
  
  <entry>
    <title>MQ之间的对比</title>
    <link href="http://trembear.github.io/2019/11/15/java/MQ%E4%B9%8B%E9%97%B4%E7%9A%84%E5%AF%B9%E6%AF%94/"/>
    <id>http://trembear.github.io/2019/11/15/java/MQ之间的对比/</id>
    <published>2019-11-15T06:58:06.000Z</published>
    <updated>2019-11-15T09:28:25.260Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="spring" scheme="http://trembear.github.io/categories/spring/"/>
    
    
  </entry>
  
  <entry>
    <title>dubbo和SpringCloud异同点</title>
    <link href="http://trembear.github.io/2019/11/15/java/dubbo%E5%92%8CSpringCloud%E5%AF%B9%E6%AF%94/"/>
    <id>http://trembear.github.io/2019/11/15/java/dubbo和SpringCloud对比/</id>
    <published>2019-11-15T06:58:06.000Z</published>
    <updated>2019-11-15T06:58:13.067Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="spring" scheme="http://trembear.github.io/categories/spring/"/>
    
    
  </entry>
  
  <entry>
    <title>spring源码阅读4-整体的流程图</title>
    <link href="http://trembear.github.io/2019/11/15/Spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB4/"/>
    <id>http://trembear.github.io/2019/11/15/Spring源码阅读/spring源码阅读4/</id>
    <published>2019-11-15T01:16:35.000Z</published>
    <updated>2019-11-28T00:44:53.700Z</updated>
    
    <content type="html"><![CDATA[<p>回顾了一下一上几节，感觉不是很清晰，同样是针对这个从文件中注入Bean到<code>SpringBeanFactory</code>这个过程，作了如下的流程图：</p><p>整体的流程图：<br><img src="https://www.swapassn.com/picRepo/img/20191115093102.png" alt></p><p>拆分xmlBeanFactory这个super()操作，主要是加载父级的beanFactory。在这个里面父级元素为null<br><img src="https://www.swapassn.com/picRepo/img/20191115093128.png" alt></p><p>第三步是这个的核心，loadBeanDefinition(resource)的具体流程<br><img src="https://www.swapassn.com/picRepo/img/20191115093148.png" alt></p><p>以上三步是大概的流程，最后一步中，读取xml是在<code>Document</code>类中具体完成的，但是前置的一些工作在<code>XmlBeanDifinitionReader</code>中完成。</p><p>doLoadDocument通过使用DocumentLoader对象来加载Document对象，但这里在使用DocumentLoader对象之前还需要做以下5个准备工作</p><ol><li>获取DocumentLoader对象。</li><li>获取EntityResolver对象。</li><li>获取ErrorHandler对象。</li><li>获取xml验证模式。</li><li>设置xml命名空间是否敏感</li></ol><p>下面是具体如何获取EntityResolver和Xml验证模式的流程图：<br><img src="https://www.swapassn.com/picRepo/img/20191115103652.png" alt></p><p>当取到Document以后，registerBeanDefinitions操作：<br><img src="https://www.swapassn.com/picRepo/img/20191115115251.png" alt></p><p>开始注册进入Spring容器：<br><img src="https://www.swapassn.com/picRepo/img/20191115115112.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;回顾了一下一上几节，感觉不是很清晰，同样是针对这个从文件中注入Bean到&lt;code&gt;SpringBeanFactory&lt;/code&gt;这个过程，作了如下的流程图：&lt;/p&gt;
&lt;p&gt;整体的流程图：&lt;br&gt;&lt;img src=&quot;https://www.swapassn.com/pic
      
    
    </summary>
    
      <category term="spring" scheme="http://trembear.github.io/categories/spring/"/>
    
    
  </entry>
  
  <entry>
    <title>高阶组件</title>
    <link href="http://trembear.github.io/2019/11/09/%E5%89%8D%E7%AB%AF/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/"/>
    <id>http://trembear.github.io/2019/11/09/前端/高阶组件/</id>
    <published>2019-11-09T04:51:47.000Z</published>
    <updated>2019-11-09T05:12:18.133Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>react组件提供了高端组件这么一个说法，高端组件可以部分替代组件之间的继承。是一个修饰器的模式，能够更灵活的处理一些组件复用的问题。<br>高阶组件本质是一个函数，此函数接受一个组件，返回一个新组件。<br>现在有这样一个需求，我们有很多业务，比如用户选择，订单选择，产品选择等。但是选择方式都是通过一个select选择框进行选择的，那么，可以将这个选择框提炼为一个公共组件，各个业务分装为业务组件，在一个实际的操作页面上，只要引入业务组件即可使用所有的功能。  </p><p>这样的好处有：</p><ol><li>新建一个业务组件特别简单，传入业务的url，名称和显示字段后，即可配合通用组件实现一个完整的select选择器。</li><li>提高代码的复用性，方便灵活的部署，修改基础组件的逻辑，对所有业务组件产生作用。</li></ol><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>基础组件</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BaseInputComp <span class="keyword">extends</span> Component&lt;BaseProp, BaseState&gt; &#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; dispatch &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      <span class="keyword">type</span>: <span class="string">'productBrandList/fetchList'</span>,</span><br><span class="line">      payload: &#123;</span><br><span class="line">        pageSize: <span class="number">10</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;children&#125;=<span class="keyword">this</span>.props</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleChange</span>(<span class="params">value: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`Selected: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> x = <span class="number">2</span></span><br><span class="line">    <span class="keyword">const</span> &#123;url&#125; = <span class="keyword">this</span>.props</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Select</span><br><span class="line">          size=<span class="string">"default"</span></span><br><span class="line">          mode=<span class="string">"multiple"</span></span><br><span class="line">          placeholder=<span class="string">"Please select"</span></span><br><span class="line">          maxTagCount=&#123;x&#125;</span><br><span class="line">          defaultValue=&#123;[]&#125;</span><br><span class="line">          onChange=&#123;handleChange&#125;</span><br><span class="line">          style=&#123;&#123;width: <span class="string">'250px'</span>&#125;&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          &#123;children&#125;</span><br><span class="line">        &lt;<span class="regexp">/Select&gt;</span></span><br><span class="line"><span class="regexp">        &#123;url&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> BaseInputComp;</span><br></pre></td></tr></table></figure><p>基础组件中的高阶组件，提供给人员组件用来进行封装。</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">withPersistentData</span>(<span class="params">name: <span class="built_in">string</span>, url: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">WrappedComponent: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> NewComponent <span class="keyword">extends</span> Component&lt;BaseProp, BaseState&gt; &#123;</span><br><span class="line">      render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">          &lt;div&gt;</span><br><span class="line">            &lt;span&gt;&#123;name&#125;选择&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">            &lt;WrappedComponent url=&#123;url&#125;&#123;...this.props&#125;/</span>&gt;</span><br><span class="line">          &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    return NewComponent</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>人员组件</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> BaseInputComp, &#123;withPersistentData&#125; <span class="keyword">from</span> <span class="string">"@/components/BaseInputComp"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;BaseProp, BaseState&#125; <span class="keyword">from</span> <span class="string">"@/components/BaseInputComp/model"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> UserProp <span class="keyword">extends</span> BaseProp &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> UserState <span class="keyword">extends</span> BaseState&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@withPersistentData</span>(<span class="string">'人员'</span>,<span class="string">'/product/info'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> UserComp <span class="keyword">extends</span> Component&lt;UserProp, UserState&gt; &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;BaseInputComp &#123;...this.props&#125;&gt;&lt;<span class="regexp">/BaseInputComp&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>使用方法</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ListProps <span class="keyword">extends</span> BaseProp &#123;</span><br><span class="line">  userId: <span class="built_in">number</span></span><br><span class="line">  dispath:Dispatch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ListState <span class="keyword">extends</span> BaseState &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@connect</span>(<span class="function">(<span class="params">&#123;exampleDemoModel&#125;: &#123; exampleDemoModel: ExampleDemoType &#125;</span>) =&gt;</span> (&#123;userId: exampleDemoModel.userId&#125;))</span><br><span class="line"><span class="keyword">class</span> ComponentDemo <span class="keyword">extends</span> Component&lt;ListProps, ListState&gt; &#123;</span><br><span class="line">  enterIconLoading = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;dispatch&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">const</span> &#123;userId&#125; = <span class="keyword">this</span>.props</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      <span class="keyword">type</span>: <span class="string">"exampleDemoModel/fetchNum"</span>,</span><br><span class="line">      payload2: &#123;</span><br><span class="line">        numCount: userId,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;userId&#125; = <span class="keyword">this</span>.props</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        当前userId：&#123;userId&#125;&lt;br/&gt;&lt;br/&gt;</span><br><span class="line">        &lt;Button onClick=&#123;<span class="keyword">this</span>.enterIconLoading&#125;&gt;切换UserId&lt;<span class="regexp">/Button&gt;&lt;br/</span>&gt;&lt;br/&gt;</span><br><span class="line">        &lt;UserComp &#123;...this.props&#125;/&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Form.create&lt;ListProps &amp; FormComponentProps&gt;()(ComponentDemo);</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题引入&quot;&gt;&lt;a href=&quot;#问题引入&quot; class=&quot;headerlink&quot; title=&quot;问题引入&quot;&gt;&lt;/a&gt;问题引入&lt;/h2&gt;&lt;p&gt;react组件提供了高端组件这么一个说法，高端组件可以部分替代组件之间的继承。是一个修饰器的模式，能够更灵活的处理一些组件复
      
    
    </summary>
    
      <category term="前端" scheme="http://trembear.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="react" scheme="http://trembear.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>dva connect的用法</title>
    <link href="http://trembear.github.io/2019/11/07/%E5%89%8D%E7%AB%AF/dva%20connect%20%E5%85%B7%E4%BD%93%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://trembear.github.io/2019/11/07/前端/dva connect 具体的用法/</id>
    <published>2019-11-07T07:18:58.000Z</published>
    <updated>2019-11-09T05:12:51.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>dva一般用connect进行model数据与组件绑定。通过例子来看具体的绑定方式。具体的流程如下：</p><ol><li>组件里面有一个按钮，点击按钮进入model层的effect方法</li><li>model中的effect执行完毕后，调用reducer刷新model中state值，同时也刷新组件的显示效果</li></ol><p>在这个结构里，有一个问题就是组件中显示的值为model中的state，那么这就需要将组件中的数据与model中的state作绑定。</p><p>现在有一个组件：</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> MyProps&#123;</span><br><span class="line">  dispatch:Dispatch</span><br><span class="line">  num:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> MyState &#123;</span><br><span class="line">  num:<span class="built_in">number</span></span><br><span class="line">  iconLoading:<span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> OtherComponent <span class="keyword">extends</span> Component&lt;MyProps, MyState&gt; &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    num:<span class="number">12</span>,</span><br><span class="line">    iconLoading:<span class="literal">false</span></span><br><span class="line">  &#125;;</span><br><span class="line">  enterIconLoading = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;dispatch&#125;=<span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; iconLoading: <span class="literal">true</span> &#125;);</span><br><span class="line">    <span class="keyword">const</span> &#123;num&#125; = <span class="keyword">this</span>.props</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      <span class="keyword">type</span>: <span class="string">"otherModel/fetchNum"</span>,<span class="comment">// 这里就会触发models层里面effects中fetchNum方法（也可以直接触发reducer中方法，看具体情况） ,test就是models里的命名空间名字</span></span><br><span class="line">      payload2: &#123;</span><br><span class="line">        numCount:num,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;iconLoading:<span class="literal">false</span>&#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;num&#125; = <span class="keyword">this</span>.props</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;Button <span class="keyword">type</span>=<span class="string">"primary"</span></span><br><span class="line">                  icon=<span class="string">"poweroff"</span></span><br><span class="line">                  loading=&#123;<span class="keyword">this</span>.state.iconLoading&#125;</span><br><span class="line">                  onClick=&#123;<span class="keyword">this</span>.enterIconLoading&#125;&gt;</span><br><span class="line">            &#123;num&#125;</span><br><span class="line">          &lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> OtherComponent;</span><br></pre></td></tr></table></figure><p>model层中代码：</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> StateType &#123;</span><br><span class="line">  num: <span class="built_in">number</span></span><br><span class="line">  iconLoading: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ModelType &#123;</span><br><span class="line">  <span class="keyword">namespace</span>: <span class="built_in">string</span>;</span><br><span class="line">  state: StateType;</span><br><span class="line">  effects: &#123;&#125;;</span><br><span class="line">  reducers: &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Model: ModelType = &#123;</span><br><span class="line">  <span class="keyword">namespace</span>: <span class="string">'otherModel'</span>,</span><br><span class="line">  state: &#123;num: <span class="number">1873</span>, iconLoading: <span class="literal">false</span>&#125;,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    addNum(state: StateType, &#123;payload: &#123;num&#125;&#125;:&#123;payload:&#123;num:<span class="built_in">number</span>&#125;&#125;) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, num&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  effects: &#123;</span><br><span class="line">    * fetchNum(&#123;payload2&#125;: &#123; payload2: AnyAction &#125;, &#123;call,put &#125;: EffectsCommandMap &amp; &#123; select: &lt;T&gt;<span class="function">(<span class="params">func: (<span class="params">state: StateType</span>) =&gt; T</span>) =&gt;</span> T &#125;) &#123;<span class="comment">//fetchNum方法名，payload2是传来的参数，是个对象，如果没参数可以写成&#123;_,&#123;call,put,select&#125;&#125;</span></span><br><span class="line">      <span class="comment">// const &#123;data&#125; = yield call(myService.doit, &#123;anum: payload2.numCount&#125;) // myService是引入service层那个js的一个名字，anum是后台要求传的参数，data就是后台返回来的数据</span></span><br><span class="line">      <span class="comment">//const m = yield select((state) =&gt; state.test.num) //select就是用来选择上面state里的，这里没用上</span></span><br><span class="line">      <span class="built_in">console</span>.log(payload2)</span><br><span class="line">      <span class="keyword">yield</span> put(&#123;</span><br><span class="line">        <span class="keyword">type</span>: <span class="string">"addNum"</span>,<span class="comment">// 这就是reducer中addNum方法, put就是用来触发上面reducer的方法，payload里就是传过去的参数。 同时它也能触发同等级effects中其他方法。</span></span><br><span class="line">        payload: &#123;</span><br><span class="line">          num: payload2.numCount + <span class="number">1</span>, <span class="comment">// 把后台返回的数据赋值给了num，假如那个reducer中方法是由这里effects去触发的，那个num名必须是这里名字num，如果reducer中方法不是这触发，那名字可随便起</span></span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Model;</span><br></pre></td></tr></table></figure><p>现在可以看到两边的逻辑都已经写好了，看看如何绑定model中的num值。</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>传统方式,使用connect，在组件中写入。这样写之后，就会在组件的props中生成一个otherModel的属性。<br>使用的时候用<code>const {otherModel}=this.props</code>即可取到。这里的<code>otherModel</code>为model 的命名空间。</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span> (<span class="params">model</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; otherModel&#125; = model </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    otherModel,<span class="comment">// 在这return,上面才能获取到</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps)(OtherComponent);</span><br></pre></td></tr></table></figure><p>如果想使用model state中的某几个属性，那么使用,如下：</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span> (<span class="params">model</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; num&#125; = model.otherModel </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    num,<span class="comment">// 在这return,上面才能获取到</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>现在一般都用@connect装饰器的模式。这种模式看起来更简单一些，但是初次使用，语法上还是需要看一下的：</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@connect</span>(<span class="function">(<span class="params">&#123;otherModel&#125;:&#123;otherModel:StateType&#125;</span>)=&gt;</span>(&#123;otherModel&#125;))</span><br></pre></td></tr></table></figure><p>在这里需要注意，这样引入的话，类似于上面的全部引入。但是如果想要部分引入属性。需要用下面的方法：</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@connect</span>(<span class="function">(<span class="params">&#123;otherModel&#125;:&#123;otherModel:StateType&#125;</span>)=&gt;</span>(&#123;num:otherModel.num&#125;))</span><br></pre></td></tr></table></figure><p>即传入的参数永远为otherModel，也就是这个唯一的命名空间</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题引入&quot;&gt;&lt;a href=&quot;#问题引入&quot; class=&quot;headerlink&quot; title=&quot;问题引入&quot;&gt;&lt;/a&gt;问题引入&lt;/h2&gt;&lt;p&gt;dva一般用connect进行model数据与组件绑定。通过例子来看具体的绑定方式。具体的流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;l
      
    
    </summary>
    
      <category term="前端" scheme="http://trembear.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="react" scheme="http://trembear.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Specification动态构建复杂查询</title>
    <link href="http://trembear.github.io/2019/11/01/JPA/Specification%E5%8A%A8%E6%80%81%E6%9E%84%E5%BB%BA%E5%A4%8D%E6%9D%82%E6%9F%A5%E8%AF%A2/"/>
    <id>http://trembear.github.io/2019/11/01/JPA/Specification动态构建复杂查询/</id>
    <published>2019-11-01T07:14:08.000Z</published>
    <updated>2019-12-03T07:55:46.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JPA查询的几种形式"><a href="#JPA查询的几种形式" class="headerlink" title="JPA查询的几种形式"></a>JPA查询的几种形式</h2><ol><li><p>基础形式<br>此种方法不用写sql，继承<code>JpaRepository</code>，适合简单的增删改查。<br>例子：一般针对简单的查询：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductAttributeValueRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">ProductAttributeValue</span>,<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteAllByCateId</span><span class="params">(Long id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteAllByAttrNameId</span><span class="params">(Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>SQL,JPQL查询<br> sql查询为原生SQL查询，JPQL查询是使用的是基于对象的查询。<br> Modifying:它说的是可以清除底层持久化上下文，就是entityManager这个类，我们知道jpa底层实现会有二级缓存，也就是在更新完数据库后，如果后面去用这个对象，你再去查这个对象，这个对象是在一级缓存，但是并没有跟数据库同步，这个时候用clearAutomatically=true,就会刷新hibernate的一级缓存了                    </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductCategoryRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">ProductCategoryEntity</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Modifying</span>(clearAutomatically = <span class="keyword">true</span>)</span><br><span class="line">    <span class="meta">@Query</span>(value = <span class="string">"update product_category pc set  pc.`is_delete`=1  where pc.`cate_id`=?1"</span>, nativeQuery = <span class="keyword">true</span>)</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteCategoryById</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>组装形式的原生SQL<br>这种形式，适合查询条件比较复杂的情况，自己组装比较灵活  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">public</span> ProductInfoDto <span class="title">searchProductInfoWithTitle</span><span class="params">(Long productInfoId)</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">"select pi.*,pb.title as brand_title,pc.title as category_title from product_info pi "</span> +</span><br><span class="line">            <span class="string">"left join product_brand pb on pi.brand_id=pb.brand_id "</span> +</span><br><span class="line">            <span class="string">"left join product_category pc on pc.cate_id=pi.cate_id "</span> +</span><br><span class="line">            <span class="string">"where pi.id="</span> + productInfoId + <span class="string">" and pi.is_delete=0 "</span>;</span><br><span class="line">    List&lt;ProductInfoDto&gt; webInfos = entityManager.createNativeQuery(sql, ProductInfoDto.class).getResultList();</span><br><span class="line">    <span class="keyword">if</span> (webInfos == <span class="keyword">null</span> || webInfos.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ProductInfoDto productInfoDto = webInfos.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> productInfoDto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Querydsl方式</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt;, <span class="title">QuerydslPredicateExecutor</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 使用方法：  </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Predicate predicate = user.firstname.equalsIgnoreCase(<span class="string">"dave"</span>)</span><br><span class="line">    .and(user.lastname.startsWithIgnoreCase(<span class="string">"mathews"</span>));</span><br><span class="line"> </span><br><span class="line">userRepository.findAll(predicate);</span><br></pre></td></tr></table></figure></li><li><p>使用Example<br>我一开始特别喜欢这种形式的查询，比较直观，ExampleMatcher是一个查询的匹配器，可以设置多种匹配规则，分页也比较直观</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Sort sort = <span class="keyword">new</span> Sort(Sort.Direction.DESC, <span class="string">"brandId"</span>);</span><br><span class="line">Pageable pageable = PaginationUtil.pageRequest(productBrandListDtoIn, sort);</span><br><span class="line">ExampleMatcher exampleMatcher = ExampleMatcher.matching().withMatcher(<span class="string">"title"</span>, ExampleMatcher.GenericPropertyMatchers.contains());</span><br><span class="line">Example&lt;ProductBrand&gt; example = Example.of(productBrandListDtoIn.getProductBrand(), exampleMatcher);</span><br><span class="line">Page&lt;ProductBrand&gt; productBrandPage =productBrandRepository.findAll(example, pageable);</span><br><span class="line">ProductBrandListDtoOut dtoOut = <span class="keyword">new</span> ProductBrandListDtoOut(productBrandPage);</span><br><span class="line"><span class="keyword">if</span> (productBrandPage.getContent().size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    productBrandPage.getContent().forEach(entity -&gt;</span><br><span class="line">            dtoOut.getList().add(dtoOut.convertToDto(entity))</span><br><span class="line">    );</span><br><span class="line">&#125;   </span><br><span class="line"><span class="keyword">return</span> dtoOut;</span><br></pre></td></tr></table></figure></li></ol><ol start="6"><li>nameQuery方法 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@NamedQuery</span>(name = <span class="string">"User.findByEmailAddress"</span>,</span><br><span class="line">  query = <span class="string">"select u from User u where u.emailAddress = ?1"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JPA查询的几种形式&quot;&gt;&lt;a href=&quot;#JPA查询的几种形式&quot; class=&quot;headerlink&quot; title=&quot;JPA查询的几种形式&quot;&gt;&lt;/a&gt;JPA查询的几种形式&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;基础形式&lt;br&gt;此种方法不用写sql，继承&lt;code&gt;Jp
      
    
    </summary>
    
      <category term="JAVA" scheme="http://trembear.github.io/categories/JAVA/"/>
    
    
      <category term="JPA Specification" scheme="http://trembear.github.io/tags/JPA-Specification/"/>
    
  </entry>
  
  <entry>
    <title>初次使用ant design pro遇到的问题</title>
    <link href="http://trembear.github.io/2019/10/26/%E5%89%8D%E7%AB%AF/%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8ant%20design%20pro%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://trembear.github.io/2019/10/26/前端/初次使用ant design pro遇到的问题/</id>
    <published>2019-10-25T17:32:53.000Z</published>
    <updated>2019-11-01T07:11:52.463Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>最近的一个项目，后台框架用的是React。本来以为直接看看项目代码就能照葫芦画瓢的，结果栽了一个跟头，在苦苦挣扎了一天后，<br>还是有很多地方看不懂，晚上冷静了一下，整理了一下看不懂的一些地方，做一下记录，很多时候都是因为TSX的语法不够熟练，导致看不懂，<br>有时间还是要重新学习一下语法,真正要彻底掌握ant design pro,需要前置学习的有es6，ts，react，jsx，dva，umi等。但是项目<br>时间的问题，彻底学习还是留待以后。其实在项目中实际运用可能会更快一些。下面是一些具体的问题</p><h2 id="TypeScript泛型的问题"><a href="#TypeScript泛型的问题" class="headerlink" title="TypeScript泛型的问题"></a>TypeScript泛型的问题</h2><p>函数中的泛型</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义学生的属性获取方法，一个返回字符串类型的name一个返回number类型的年龄</span></span><br><span class="line"><span class="keyword">let</span> itemFun = &#123;</span><br><span class="line">    getName: (name: <span class="built_in">string</span>): <span class="function"><span class="params">string</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;,</span><br><span class="line">    getAge: (age: <span class="built_in">number</span>):<span class="function"><span class="params">number</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//错误做法，这样的话value没有类型</span></span><br><span class="line"><span class="keyword">let</span> student1 = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="keyword">let</span> student1 = (value: <span class="built_in">any</span>):<span class="function"><span class="params">any</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误做法 会找不到T类型的类</span></span><br><span class="line"><span class="keyword">let</span> student3 = &lt;T&gt;(value: T): <span class="function"><span class="params">T</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//规范做法</span></span><br><span class="line"><span class="comment">//解释：Value: T 表示声明参数是 T 类型的，后面的 : T 表示返回值也是 T 类型的。</span></span><br><span class="line"><span class="keyword">let</span> student3 = &lt;T <span class="keyword">extends</span> &#123;&#125;&gt;(value: T): <span class="function"><span class="params">T</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一种形式</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明泛型类，类型变量为 T</span></span><br><span class="line"><span class="keyword">class</span> FilteredList&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// 声明过滤器是以 T 为参数类型，返回 boolean 的函数表达式</span></span><br><span class="line">  filter: <span class="function">(<span class="params">v: T</span>) =&gt;</span> <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="comment">// 声明数据是 T 数组类型</span></span><br><span class="line">  data: T[];</span><br><span class="line">  <span class="comment">//构造器中 传入的filter是一个函数，T为参数，返回值为boolean</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">filter: (v: T) =&gt; <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.filter = filter;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add(value: T) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.filter(value)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.data.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> all(): T[] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 string 类型的 FilteredList</span></span><br><span class="line"><span class="keyword">const</span> validStrings = <span class="keyword">new</span> FilteredList&lt;<span class="built_in">string</span>&gt;(<span class="function"><span class="params">s</span> =&gt;</span> !s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 number 类型的 FilteredList</span></span><br><span class="line"><span class="keyword">const</span> positiveNumber  = <span class="keyword">new</span> FilteredList&lt;<span class="built_in">number</span>&gt;(<span class="function"><span class="params">n</span> =&gt;</span> n &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>最常见一种形式的解释</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IProps &#123;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  size?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> IState &#123;</span><br><span class="line">  aState: <span class="built_in">string</span>;</span><br><span class="line">  bState: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> Animal <span class="keyword">extends</span> Component&lt;IProps, IState&gt; &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">props:IProps</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            aState: <span class="string">''</span>,</span><br><span class="line">            bState: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用泛型进行 Props、 State 的类型定义。在这个两个泛型里面，前一个为Props，后一个为State。这样写的目的是在<br>定义后使用 this.state 和 this.props 时可以在编辑器中获得更好的智能提示，并且会对类型进行检查。</p><h2 id="状态和属性"><a href="#状态和属性" class="headerlink" title="状态和属性"></a>状态和属性</h2><p><code>props</code> 是组件对外的接口，<code>state</code> 是组件对内的接口。组件内可以引用其他组件，组件之间的引用形成了一个树状结构（组件树），如果下层组件需要使用上层组件的数据或方法，上层组件就可以通过下层组件的props属性进行传递，因此props是组件对外的接口。组件除了使用上层组件传递的数据外，自身也可能需要维护管理数据，这就是组件对内的接口state。根据对外接口props 和对内接口state，组件计算出对应界面的UI。</p><p><strong>主要区别：</strong></p><ul><li>State是可变的，是一组用于反映组件UI变化的状态集合；state是私有的，可以认为state是组件的“私有属性（或者是局部属性）</li><li>而Props对于使用它的组件来说，是只读的，要想修改Props，只能通过该组件的父组件修改。<br>在组件状态上移的场景中，父组件正是通过子组件的Props, 传递给子组件其所需要的状态。</li></ul><h3 id="如何修改states"><a href="#如何修改states" class="headerlink" title="如何修改states"></a>如何修改states</h3><p>states有几个地方需要注意</p><ol><li>用setState 修改State</li><li>State 的更新是异步的</li><li>State更新会被合并</li><li>state类型是数组</li><li>state类型是对象<h3 id="向子组件传递数据"><a href="#向子组件传递数据" class="headerlink" title="向子组件传递数据"></a>向子组件传递数据</h3>我们说 props 是组件对外的接口，state 是组件对内的接口。<br>一个组件可以选择将 state(状态) 向下传递，作为其子组件的 props(属性)：<figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent title=&#123;<span class="keyword">this</span>.state.title&#125;/&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="自定义表单组件回传值"><a href="#自定义表单组件回传值" class="headerlink" title="自定义表单组件回传值"></a>自定义表单组件回传值</h2><p>ant-design给我们提供了Form表单组件,但是如果想把其中的某些输入框转为组件，原有的表单取值和验证使用保持不变，该如何实现：<br>父组件：</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;FormItem label=<span class="string">"选项"</span>&gt;</span><br><span class="line">       getFieldDecorator(<span class="string">'option'</span>, &#123;</span><br><span class="line">              initialValue: [defaultValue.option || <span class="string">'0'</span>, defaultValue.word]</span><br><span class="line">         &#125;)(</span><br><span class="line">                &lt;OptionSelect/&gt;</span><br><span class="line">         )&#125;</span><br><span class="line">&lt;<span class="regexp">/FormItem&gt;</span></span><br></pre></td></tr></table></figure><p>父组件使用getFieldDecorator最后可以取到option选项的值。<br>子组件：</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;value&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">  <span class="keyword">return</span>(</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">          &lt;Select value=&#123;value[<span class="number">0</span>]&#125; onChange=&#123;<span class="keyword">this</span>.selectChange&#125;&gt;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &lt;<span class="regexp">/Select&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Input  value=&#123;value[1]&#125; onChange=&#123;this.inputChange&#125;/</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">selectChange(val) &#123;</span></span><br><span class="line"><span class="regexp">    const &#123;onChange&#125; = this.props;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/通知父组件更新</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/封装数据传参</span></span><br><span class="line"><span class="regexp">    let changeVal;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/...</span></span><br><span class="line"><span class="regexp">    onChange(changeVal)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">inputChange(e) &#123;</span></span><br><span class="line"><span class="regexp">  const &#123;onChange&#125; = this.props;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">OptionSelect.propTypes = &#123;</span></span><br><span class="line"><span class="regexp">    value: PropTypes.array,</span></span><br><span class="line"><span class="regexp">    onChange: PropTypes.func</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p>getFieldDecorator这个方法会向组件注入value参数，onChange方法。子组件通过value参数来初始化值，通过onChange方法通知父组件更新。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原因&quot;&gt;&lt;a href=&quot;#原因&quot; class=&quot;headerlink&quot; title=&quot;原因&quot;&gt;&lt;/a&gt;原因&lt;/h2&gt;&lt;p&gt;最近的一个项目，后台框架用的是React。本来以为直接看看项目代码就能照葫芦画瓢的，结果栽了一个跟头，在苦苦挣扎了一天后，&lt;br&gt;还是有很多
      
    
    </summary>
    
      <category term="前端" scheme="http://trembear.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="react" scheme="http://trembear.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>node study1</title>
    <link href="http://trembear.github.io/2019/10/22/NodeSutdy/NodeStudy1/"/>
    <id>http://trembear.github.io/2019/10/22/NodeSutdy/NodeStudy1/</id>
    <published>2019-10-22T06:48:43.000Z</published>
    <updated>2019-10-22T09:30:51.993Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一个例子"><a href="#第一个例子" class="headerlink" title="第一个例子"></a>第一个例子</h2><p>使用node引入 http组件，然后监听8888端口：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 发送 HTTP 头部</span></span><br><span class="line">    <span class="comment">// HTTP 状态值: 200 : OK</span></span><br><span class="line">    <span class="comment">// 内容类型: text/plain</span></span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送响应数据 "Hello World"</span></span><br><span class="line">    response.end(<span class="string">'Hello World\n'</span>);</span><br><span class="line">&#125;).listen(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终端打印如下信息</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server running at http://127.0.0.1:8888/'</span>);</span><br></pre></td></tr></table></figure><p>执行<code>node server.js</code>，进入浏览器即可访问该端口</p><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：</p><ol><li>允许用户从NPM服务器下载别人编写的第三方包到本地使用。  </li><li>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。</li><li>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。  </li></ol><blockquote><p>使用淘宝镜像 <code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code>  </p></blockquote><p>安装express（Node.js web的框架模块）的命令：<code>npm install express</code></p><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>Node.js 异步编程的直接体现就是回调。异步编程依托于回调来实现。</p><p>阻塞代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入读取文件的模块</span></span><br><span class="line"><span class="keyword">var</span> fs=<span class="built_in">require</span>(<span class="string">"fs"</span>)</span><br><span class="line"><span class="comment">//阻塞代码</span></span><br><span class="line"><span class="keyword">var</span> date=fs.readFileSync(<span class="string">'server.js'</span> );</span><br><span class="line"><span class="built_in">console</span>.log(date.toString())</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序结束"</span>)</span><br></pre></td></tr></table></figure><p>非阻塞代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs=<span class="built_in">require</span>(<span class="string">"fs"</span>)</span><br><span class="line"><span class="comment">//引入读取文件的模块</span></span><br><span class="line">fs.readFile(<span class="string">'server.js'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">err,date</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">console</span>.log(err)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">console</span>.log(date.toString())</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行结束!"</span>);<span class="comment">//执行结果：此句话先输出</span></span><br></pre></td></tr></table></figure><p>##事件驱动程序<br>Node.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。<br>这个模型非常高效可扩展性非常强，因为webserver一直接受请求而不等待任何读写操作。（这也被称之为非阻塞式IO或者事件驱动IO）<br>类似于观察者模式，事件相当于一个主题(Subject)，而所有注册到这个事件上的处理函数相当于观察者(Observer)。<br><strong>示例</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 events 模块</span></span><br><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="comment">// 创建 eventEmitter 对象</span></span><br><span class="line"><span class="keyword">var</span> eventEmitter = <span class="keyword">new</span> events.EventEmitter();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 创建事件处理程序</span></span><br><span class="line"><span class="keyword">var</span> connectHandler = <span class="function"><span class="keyword">function</span> <span class="title">connected</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'连接成功。'</span>);</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 触发 data_received 事件 </span></span><br><span class="line">   eventEmitter.emit(<span class="string">'data_received'</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 绑定 connection 事件处理程序</span></span><br><span class="line">eventEmitter.on(<span class="string">'connection'</span>, connectHandler);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用匿名函数绑定 data_received 事件</span></span><br><span class="line">eventEmitter.on(<span class="string">'data_received'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'数据接收成功。'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 触发 connection 事件 </span></span><br><span class="line">eventEmitter.emit(<span class="string">'connection'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行完毕。"</span>);</span><br></pre></td></tr></table></figure><h2 id="EventEmitter"><a href="#EventEmitter" class="headerlink" title="EventEmitter"></a>EventEmitter</h2><p>Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。</p><p>Node.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。</p><p>EventEmitter 的核心就是<strong>事件触发</strong>与<strong>事件监听器</strong>功能的封装</p><p>常见的EventEmitter执行方法有：</p><p>Tables:</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>addListener(event, listener)</td><td>为指定事件添加一个监听器到监听器数组的尾部。</td></tr><tr><td>on(event, listener)</td><td>为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。</td></tr><tr><td>once(event, listener)</td><td>为指定事件注册一个单次监听器，即 监听器最多只会触发一次。</td></tr><tr><td>removeListener(event, listener)</td><td>移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。</td></tr><tr><td>removeAllListeners(event, listener)</td><td>移除所有事件的所有监听器。</td></tr><tr><td>setMaxListeners(n)</td><td>EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。</td></tr><tr><td>listeners(event)</td><td>返回指定事件的监听器数组。</td></tr><tr><td>emit(event, [arg1], [arg2], […])</td><td>按监听器的顺序执行执行每个监听器。</td></tr></tbody></table><h2 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一个例子&quot;&gt;&lt;a href=&quot;#第一个例子&quot; class=&quot;headerlink&quot; title=&quot;第一个例子&quot;&gt;&lt;/a&gt;第一个例子&lt;/h2&gt;&lt;p&gt;使用node引入 http组件，然后监听8888端口：&lt;/p&gt;
&lt;figure class=&quot;highlight j
      
    
    </summary>
    
      <category term="spring" scheme="http://trembear.github.io/categories/spring/"/>
    
    
  </entry>
  
  <entry>
    <title>mybatis-generator 配置详解</title>
    <link href="http://trembear.github.io/2019/07/20/mybatis-generator%20%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>http://trembear.github.io/2019/07/20/mybatis-generator 配置详解/</id>
    <published>2019-07-20T09:39:00.000Z</published>
    <updated>2019-10-22T01:43:07.409Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>MyBatis官方提供了逆向工程 mybatis-generator，可以针对数据库表自动生成MyBatis执行所需要的代码（如Mapper.java、Mapper.xml、POJO）。mybatis-generator 有三种用法：命令行、eclipse插件、maven插件。而maven插件的方式比较通用，本文也将概述maven插件的使用方式。</p><h2 id="配置形式"><a href="#配置形式" class="headerlink" title="配置形式"></a>配置形式</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE generatorConfiguration</span></span><br><span class="line"><span class="meta">  PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"</span></span><br><span class="line"><span class="meta">"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置生成器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 可以用于加载配置项或者配置文件，在整个配置文件中就可以使用$&#123;propertyKey&#125;的方式来引用配置项</span></span><br><span class="line"><span class="comment">    resource：配置资源加载地址，使用resource，MBG从classpath开始找，比如com/myproject/generatorConfig.properties        </span></span><br><span class="line"><span class="comment">    url：配置资源加载地质，使用URL的方式，比如file:///C:/myfolder/generatorConfig.properties.</span></span><br><span class="line"><span class="comment">    注意，两个属性只能选址一个;</span></span><br><span class="line"><span class="comment">    另外，如果使用了mybatis-generator-maven-plugin，那么在pom.xml中定义的properties都可以直接在generatorConfig.xml中使用</span></span><br><span class="line"><span class="comment">&lt;properties resource="" url="" /&gt;</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">&lt;!-- 在MBG工作的时候，需要额外加载的依赖包</span></span><br><span class="line"><span class="comment">     location属性指明加载jar/zip包的全路径</span></span><br><span class="line"><span class="comment">&lt;classPathEntry location="/Program Files/IBM/SQLLIB/java/db2java.zip" /&gt;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    context:生成一组对象的环境 </span></span><br><span class="line"><span class="comment">    id:必选，上下文id，用于在生成错误时提示</span></span><br><span class="line"><span class="comment">    defaultModelType:指定生成对象的样式</span></span><br><span class="line"><span class="comment">        1，conditional：类似hierarchical；</span></span><br><span class="line"><span class="comment">        2，flat：所有内容（主键，blob）等全部生成在一个对象中；</span></span><br><span class="line"><span class="comment">        3，hierarchical：主键生成一个XXKey对象(key class)，Blob等单独生成一个对象，其他简单属性在一个对象中(record class)</span></span><br><span class="line"><span class="comment">    targetRuntime:</span></span><br><span class="line"><span class="comment">        1，MyBatis3：默认的值，生成基于MyBatis3.x以上版本的内容，包括XXXBySample；</span></span><br><span class="line"><span class="comment">        2，MyBatis3Simple：类似MyBatis3，只是不生成XXXBySample；</span></span><br><span class="line"><span class="comment">    introspectedColumnImpl：类全限定名，用于扩展MBG</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">"mysql"</span> <span class="attr">defaultModelType</span>=<span class="string">"hierarchical"</span> <span class="attr">targetRuntime</span>=<span class="string">"MyBatis3Simple"</span> &gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 自动识别数据库关键字，默认false，如果设置为true，根据SqlReservedWords中定义的关键字列表；</span></span><br><span class="line"><span class="comment">        一般保留默认值，遇到数据库关键字（Java关键字），使用columnOverride覆盖</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"autoDelimitKeywords"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 生成的Java文件的编码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"javaFileEncoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 格式化java代码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"javaFormatter"</span> <span class="attr">value</span>=<span class="string">"org.mybatis.generator.api.dom.DefaultJavaFormatter"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 格式化XML代码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"xmlFormatter"</span> <span class="attr">value</span>=<span class="string">"org.mybatis.generator.api.dom.DefaultXmlFormatter"</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- beginningDelimiter和endingDelimiter：指明数据库的用于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是`反引号； --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beginningDelimiter"</span> <span class="attr">value</span>=<span class="string">"`"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"endingDelimiter"</span> <span class="attr">value</span>=<span class="string">"`"</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 必须要有的，使用这个配置链接数据库</span></span><br><span class="line"><span class="comment">        @<span class="doctag">TODO:</span>是否可以扩展</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">"com.mysql.jdbc.Driver"</span> <span class="attr">connectionURL</span>=<span class="string">"jdbc:mysql:///pss"</span> <span class="attr">userId</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"admin"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 这里面可以设置property属性，每一个property属性都设置到配置的Driver上 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- java类型处理器 </span></span><br><span class="line"><span class="comment">        用于处理DB中的类型到Java中的类型，默认使用JavaTypeResolverDefaultImpl；</span></span><br><span class="line"><span class="comment">        注意一点，默认会先尝试使用Integer，Long，Short等来对应DECIMAL和 NUMERIC数据类型； </span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">javaTypeResolver</span> <span class="attr">type</span>=<span class="string">"org.mybatis.generator.internal.types.JavaTypeResolverDefaultImpl"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">            true：使用BigDecimal对应DECIMAL和 NUMERIC数据类型</span></span><br><span class="line"><span class="comment">            false：默认,</span></span><br><span class="line"><span class="comment">                scale&gt;0;length&gt;18：使用BigDecimal;</span></span><br><span class="line"><span class="comment">                scale=0;length[10,18]：使用Long；</span></span><br><span class="line"><span class="comment">                scale=0;length[5,9]：使用Integer；</span></span><br><span class="line"><span class="comment">                scale=0;length&lt;5：使用Short；</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"forceBigDecimals"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- java模型创建器，是必须要的元素</span></span><br><span class="line"><span class="comment">        负责：1，key类（见context的defaultModelType）；2，java类；3，查询类</span></span><br><span class="line"><span class="comment">        targetPackage：生成的类要放的包，真实的包受enableSubPackages属性控制；</span></span><br><span class="line"><span class="comment">        targetProject：目标项目，指定一个存在的目录下，生成的内容会放到指定目录中，如果目录不存在，MBG不会自动建目录</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"com._520it.mybatis.domain"</span> <span class="attr">targetProject</span>=<span class="string">"src/main/java"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  for MyBatis3/MyBatis3Simple</span></span><br><span class="line"><span class="comment">            自动为每一个生成的类创建一个构造方法，构造方法包含了所有的field；而不是使用setter；</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"constructorBased"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">&lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">&lt;!-- for MyBatis3 / MyBatis3Simple</span></span><br><span class="line"><span class="comment">            是否创建一个不可变的类，如果为true，</span></span><br><span class="line"><span class="comment">            那么MBG会创建一个没有setter方法的类，取而代之的是类似constructorBased的类</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"immutable"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">&lt;!-- 设置一个根对象，</span></span><br><span class="line"><span class="comment">            如果设置了这个根对象，那么生成的keyClass或者recordClass会继承这个类；在Table的rootClass属性中可以覆盖该选项</span></span><br><span class="line"><span class="comment">            注意：如果在key class或者record class中有root class相同的属性，MBG就不会重新生成这些属性了，包括：</span></span><br><span class="line"><span class="comment">                1，属性名相同，类型相同，有相同的getter/setter方法；</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"rootClass"</span> <span class="attr">value</span>=<span class="string">"com._520it.mybatis.domain.BaseDomain"</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">&lt;!-- 设置是否在getter方法中，对String类型字段调用trim()方法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"trimStrings"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 生成SQL map的XML文件生成器，</span></span><br><span class="line"><span class="comment">        注意，在Mybatis3之后，我们可以使用mapper.xml文件+Mapper接口（或者不用mapper接口），</span></span><br><span class="line"><span class="comment">            或者只使用Mapper接口+Annotation，所以，如果 javaClientGenerator配置中配置了需要生成XML的话，这个元素就必须配置</span></span><br><span class="line"><span class="comment">        targetPackage/targetProject:同javaModelGenerator</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"com._520it.mybatis.mapper"</span> <span class="attr">targetProject</span>=<span class="string">"src/main/resources"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 对于mybatis来说，即生成Mapper接口，注意，如果没有配置该元素，那么默认不会生成Mapper接口 </span></span><br><span class="line"><span class="comment">        targetPackage/targetProject:同javaModelGenerator</span></span><br><span class="line"><span class="comment">        type：选择怎么生成mapper接口（在MyBatis3/MyBatis3Simple下）：</span></span><br><span class="line"><span class="comment">            1，ANNOTATEDMAPPER：会生成使用Mapper接口+Annotation的方式创建（SQL生成在annotation中），不会生成对应的XML；</span></span><br><span class="line"><span class="comment">            2，MIXEDMAPPER：使用混合配置，会生成Mapper接口，并适当添加合适的Annotation，但是XML会生成在XML中；</span></span><br><span class="line"><span class="comment">            3，XMLMAPPER：会生成Mapper接口，接口完全依赖XML；</span></span><br><span class="line"><span class="comment">        注意，如果context是MyBatis3Simple：只支持ANNOTATEDMAPPER和XMLMAPPER</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"com._520it.mybatis.mapper"</span> <span class="attr">type</span>=<span class="string">"ANNOTATEDMAPPER"</span> <span class="attr">targetProject</span>=<span class="string">"src/main/java"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">&lt;!-- 可以为所有生成的接口添加一个父接口，但是MBG只负责生成，不负责检查</span></span><br><span class="line"><span class="comment">        &lt;property name="rootInterface" value=""/&gt;</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 选择一个table来生成相关文件，可以有一个或多个table，必须要有table元素</span></span><br><span class="line"><span class="comment">        选择的table会生成一下文件：</span></span><br><span class="line"><span class="comment">        1，SQL map文件</span></span><br><span class="line"><span class="comment">        2，生成一个主键类；</span></span><br><span class="line"><span class="comment">        3，除了BLOB和主键的其他字段的类；</span></span><br><span class="line"><span class="comment">        4，包含BLOB的类；</span></span><br><span class="line"><span class="comment">        5，一个用户生成动态查询的条件类（selectByExample, deleteByExample），可选；</span></span><br><span class="line"><span class="comment">        6，Mapper接口（可选）</span></span><br><span class="line"><span class="comment">        tableName（必要）：要生成对象的表名；</span></span><br><span class="line"><span class="comment">        注意：大小写敏感问题。正常情况下，MBG会自动的去识别数据库标识符的大小写敏感度，在一般情况下，MBG会</span></span><br><span class="line"><span class="comment">            根据设置的schema，catalog或tablename去查询数据表，按照下面的流程：</span></span><br><span class="line"><span class="comment">            1，如果schema，catalog或tablename中有空格，那么设置的是什么格式，就精确的使用指定的大小写格式去查询；</span></span><br><span class="line"><span class="comment">            2，否则，如果数据库的标识符使用大写的，那么MBG自动把表名变成大写再查找；</span></span><br><span class="line"><span class="comment">            3，否则，如果数据库的标识符使用小写的，那么MBG自动把表名变成小写再查找；</span></span><br><span class="line"><span class="comment">            4，否则，使用指定的大小写格式查询；</span></span><br><span class="line"><span class="comment">        另外的，如果在创建表的时候，使用的""把数据库对象规定大小写，就算数据库标识符是使用的大写，在这种情况下也会使用给定的大小写来创建表名；</span></span><br><span class="line"><span class="comment">        这个时候，请设置delimitIdentifiers="true"即可保留大小写格式；</span></span><br><span class="line"><span class="comment">        可选：</span></span><br><span class="line"><span class="comment">        1，schema：数据库的schema；</span></span><br><span class="line"><span class="comment">        2，catalog：数据库的catalog；</span></span><br><span class="line"><span class="comment">        3，alias：为数据表设置的别名，如果设置了alias，那么生成的所有的SELECT SQL语句中，列名会变成：alias_actualColumnName</span></span><br><span class="line"><span class="comment">        4，domainObjectName：生成的domain类的名字，如果不设置，直接使用表名作为domain类的名字；可以设置为somepck.domainName，那么会自动把domainName类再放到somepck包里面；</span></span><br><span class="line"><span class="comment">        5，enableInsert（默认true）：指定是否生成insert语句；</span></span><br><span class="line"><span class="comment">        6，enableSelectByPrimaryKey（默认true）：指定是否生成按照主键查询对象的语句（就是getById或get）；</span></span><br><span class="line"><span class="comment">        7，enableSelectByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询语句；</span></span><br><span class="line"><span class="comment">        8，enableUpdateByPrimaryKey（默认true）：指定是否生成按照主键修改对象的语句（即update)；</span></span><br><span class="line"><span class="comment">        9，enableDeleteByPrimaryKey（默认true）：指定是否生成按照主键删除对象的语句（即delete）；</span></span><br><span class="line"><span class="comment">        10，enableDeleteByExample（默认true）：MyBatis3Simple为false，指定是否生成动态删除语句；</span></span><br><span class="line"><span class="comment">        11，enableCountByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询总条数语句（用于分页的总条数查询）；</span></span><br><span class="line"><span class="comment">        12，enableUpdateByExample（默认true）：MyBatis3Simple为false，指定是否生成动态修改语句（只修改对象中不为空的属性）；</span></span><br><span class="line"><span class="comment">        13，modelType：参考context元素的defaultModelType，相当于覆盖；</span></span><br><span class="line"><span class="comment">        14，delimitIdentifiers：参考tableName的解释，注意，默认的delimitIdentifiers是双引号，如果类似MYSQL这样的数据库，使用的是`（反引号，那么还需要设置context的beginningDelimiter和endingDelimiter属性）</span></span><br><span class="line"><span class="comment">        15，delimitAllColumns：设置是否所有生成的SQL中的列名都使用标识符引起来。默认为false，delimitIdentifiers参考context的属性</span></span><br><span class="line"><span class="comment">        注意，table里面很多参数都是对javaModelGenerator，context等元素的默认属性的一个复写；</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"userinfo"</span> &gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">&lt;!-- 参考 javaModelGenerator 的 constructorBased属性--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"constructorBased"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">&lt;!-- 默认为false，如果设置为true，在生成的SQL中，table名字不会加上catalog或schema； --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"ignoreQualifiersAtRuntime"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">&lt;!-- 参考 javaModelGenerator 的 immutable 属性 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"immutable"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">&lt;!-- 指定是否只生成domain类，如果设置为true，只生成domain类，如果还配置了sqlMapGenerator，那么在mapper XML文件中，只生成resultMap元素 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"modelOnly"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">&lt;!-- 参考 javaModelGenerator 的 rootClass 属性 </span></span><br><span class="line"><span class="comment">        &lt;property name="rootClass" value=""/&gt;</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">&lt;!-- 参考javaClientGenerator 的  rootInterface 属性</span></span><br><span class="line"><span class="comment">        &lt;property name="rootInterface" value=""/&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">&lt;!-- 如果设置了runtimeCatalog，那么在生成的SQL中，使用该指定的catalog，而不是table元素上的catalog </span></span><br><span class="line"><span class="comment">        &lt;property name="runtimeCatalog" value=""/&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">&lt;!-- 如果设置了runtimeSchema，那么在生成的SQL中，使用该指定的schema，而不是table元素上的schema </span></span><br><span class="line"><span class="comment">        &lt;property name="runtimeSchema" value=""/&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">&lt;!-- 如果设置了runtimeTableName，那么在生成的SQL中，使用该指定的tablename，而不是table元素上的tablename </span></span><br><span class="line"><span class="comment">        &lt;property name="runtimeTableName" value=""/&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">&lt;!-- 注意，该属性只针对MyBatis3Simple有用；</span></span><br><span class="line"><span class="comment">            如果选择的runtime是MyBatis3Simple，那么会生成一个SelectAll方法，如果指定了selectAllOrderByClause，那么会在该SQL中添加指定的这个order条件；</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"selectAllOrderByClause"</span> <span class="attr">value</span>=<span class="string">"age desc,username asc"</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">&lt;!-- 如果设置为true，生成的model类会直接使用column本身的名字，而不会再使用驼峰命名方法，比如BORN_DATE，生成的属性名字就是BORN_DATE,而不会是bornDate --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"useActualColumnNames"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment">&lt;!-- generatedKey用于生成生成主键的方法，</span></span><br><span class="line"><span class="comment">            如果设置了该元素，MBG会在生成的&lt;insert&gt;元素中生成一条正确的&lt;selectKey&gt;元素，该元素可选</span></span><br><span class="line"><span class="comment">            column:主键的列名；</span></span><br><span class="line"><span class="comment">            sqlStatement：要生成的selectKey语句，有以下可选项：</span></span><br><span class="line"><span class="comment">                Cloudscape:相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL()</span></span><br><span class="line"><span class="comment">                DB2       :相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL()</span></span><br><span class="line"><span class="comment">                DB2_MF    :相当于selectKey的SQL为：SELECT IDENTITY_VAL_LOCAL() FROM SYSIBM.SYSDUMMY1</span></span><br><span class="line"><span class="comment">                Derby      :相当于selectKey的SQL为：VALUES IDENTITY_VAL_LOCAL()</span></span><br><span class="line"><span class="comment">                HSQLDB      :相当于selectKey的SQL为：CALL IDENTITY()</span></span><br><span class="line"><span class="comment">                Informix  :相当于selectKey的SQL为：select dbinfo('sqlca.sqlerrd1') from systables where tabid=1</span></span><br><span class="line"><span class="comment">                MySql      :相当于selectKey的SQL为：SELECT LAST_INSERT_ID()</span></span><br><span class="line"><span class="comment">                SqlServer :相当于selectKey的SQL为：SELECT SCOPE_IDENTITY()</span></span><br><span class="line"><span class="comment">                SYBASE      :相当于selectKey的SQL为：SELECT @@IDENTITY</span></span><br><span class="line"><span class="comment">                JDBC      :相当于在生成的insert元素上添加useGeneratedKeys="true"和keyProperty属性</span></span><br><span class="line"><span class="comment">        &lt;generatedKey column="" sqlStatement=""/&gt;</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">            该元素会在根据表中列名计算对象属性名之前先重命名列名，非常适合用于表中的列都有公用的前缀字符串的时候，</span></span><br><span class="line"><span class="comment">            比如列名为：CUST_ID,CUST_NAME,CUST_EMAIL,CUST_ADDRESS等；</span></span><br><span class="line"><span class="comment">            那么就可以设置searchString为"^CUST_"，并使用空白替换，那么生成的Customer对象中的属性名称就不是</span></span><br><span class="line"><span class="comment">            custId,custName等，而是先被替换为ID,NAME,EMAIL,然后变成属性：id，name，email；</span></span><br><span class="line"><span class="comment">            注意，MBG是使用java.util.regex.Matcher.replaceAll来替换searchString和replaceString的，</span></span><br><span class="line"><span class="comment">            如果使用了columnOverride元素，该属性无效；</span></span><br><span class="line"><span class="comment">        &lt;columnRenamingRule searchString="" replaceString=""/&gt;</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">         <span class="comment">&lt;!-- 用来修改表中某个列的属性，MBG会使用修改后的列来生成domain的属性；</span></span><br><span class="line"><span class="comment">             column:要重新设置的列名；</span></span><br><span class="line"><span class="comment">             注意，一个table元素中可以有多个columnOverride元素哈~</span></span><br><span class="line"><span class="comment">          --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">columnOverride</span> <span class="attr">column</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!-- 使用property属性来指定列要生成的属性名称 --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"property"</span> <span class="attr">value</span>=<span class="string">"userName"</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">             <span class="comment">&lt;!-- javaType用于指定生成的domain的属性类型，使用类型的全限定名</span></span><br><span class="line"><span class="comment">             &lt;property name="javaType" value=""/&gt;</span></span><br><span class="line"><span class="comment">              --&gt;</span></span><br><span class="line"> </span><br><span class="line">             <span class="comment">&lt;!-- jdbcType用于指定该列的JDBC类型 </span></span><br><span class="line"><span class="comment">             &lt;property name="jdbcType" value=""/&gt;</span></span><br><span class="line"><span class="comment">              --&gt;</span></span><br><span class="line"> </span><br><span class="line">             <span class="comment">&lt;!-- typeHandler 用于指定该列使用到的TypeHandler，如果要指定，配置类型处理器的全限定名</span></span><br><span class="line"><span class="comment">                 注意，mybatis中，不会生成到mybatis-config.xml中的typeHandler</span></span><br><span class="line"><span class="comment">                 只会生成类似：where id = #&#123;id,jdbcType=BIGINT,typeHandler=com._520it.mybatis.MyTypeHandler&#125;的参数描述</span></span><br><span class="line"><span class="comment">             &lt;property name="jdbcType" value=""/&gt;</span></span><br><span class="line"><span class="comment">             --&gt;</span></span><br><span class="line"> </span><br><span class="line">             <span class="comment">&lt;!-- 参考table元素的delimitAllColumns配置，默认为false</span></span><br><span class="line"><span class="comment">             &lt;property name="delimitedColumnName" value=""/&gt;</span></span><br><span class="line"><span class="comment">              --&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">columnOverride</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">         <span class="comment">&lt;!-- ignoreColumn设置一个MGB忽略的列，如果设置了改列，那么在生成的domain中，生成的SQL中，都不会有该列出现 </span></span><br><span class="line"><span class="comment">             column:指定要忽略的列的名字；</span></span><br><span class="line"><span class="comment">             delimitedColumnName：参考table元素的delimitAllColumns配置，默认为false</span></span><br><span class="line"><span class="comment">             注意，一个table元素中可以有多个ignoreColumn元素</span></span><br><span class="line"><span class="comment">         &lt;ignoreColumn column="deptId" delimitedColumnName=""/&gt;</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;MyBatis官方提供了逆向工程 mybatis-generator，可以针对数据库表自动生成MyBatis执行所需要的代码（如Mapper
      
    
    </summary>
    
      <category term="spring" scheme="http://trembear.github.io/categories/spring/"/>
    
    
  </entry>
  
  <entry>
    <title>spring源码阅读3-四个默认标签解析</title>
    <link href="http://trembear.github.io/2019/07/03/Spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB3/"/>
    <id>http://trembear.github.io/2019/07/03/Spring源码阅读/spring源码阅读3/</id>
    <published>2019-07-03T09:39:00.000Z</published>
    <updated>2019-10-22T01:35:29.719Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇是关于解析xml文件的内容，在XmlBeanDefinitionReader类中，主要是doLoadBeanDefinitions方法中的解析步骤，这一篇继续跟进注册步骤。<br><img src="https://www.swapassn.com/picRepo/img/20190716094914.png" alt><br>在接下来的过程中，resource被包装为XmlReaderContext，Document转为Element，被documentReader注册到spring中。在具体的doRegisterBeanDefinitions方法中，包含了具体的注册流程parseBeanDefinitions方法。<br><img src="https://www.swapassn.com/picRepo/img/20190716100314.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇是关于解析xml文件的内容，在XmlBeanDefinitionReader类中，主要是doLoadBeanDefinitions方法中的解析步骤，这一篇继续跟进注册步骤。&lt;br&gt;&lt;img src=&quot;https://www.swapassn.com/picRepo/i
      
    
    </summary>
    
      <category term="spring" scheme="http://trembear.github.io/categories/spring/"/>
    
    
  </entry>
  
  <entry>
    <title>面向服务的架构相关的一些概念</title>
    <link href="http://trembear.github.io/2019/07/03/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
    <id>http://trembear.github.io/2019/07/03/面向服务架构的概念/</id>
    <published>2019-07-03T09:39:00.000Z</published>
    <updated>2019-10-22T01:40:34.340Z</updated>
    
    <content type="html"><![CDATA[<p>关于软件系统的架构设计，是一个太多人喜欢讨论的问题，尤其是对软件开发不了解的人士来说，总是被各种各样的概念绕来绕去。从更高的层次，能够很清晰的列出这些众多概念的区别，而身在开发一线的我们更多的是对这些概念有一些感性的、朴素的认识。将之内化到自己的工作中去，才能更好的发挥架构的优势。</p><p>##微服务和SOA的区别<br>微服务(MSA)是SOA发展出来的产物，它是一种比较现代化的细粒度的SOA实现方式.</p><p>##ESB<br><img src="https://www.swapassn.com/picRepo/img/20190730160000.png" alt><br>ESB(enterprise service bus)曾经着实跟随着SOA火了一阵子，从名称就能知道，它的概念借鉴了计算机组成原理中的通信模型——总线，所有需要和外部系统通信的系统，统统接入ESB，岂不是完美地兼容了现有的互相隔离的异构系统，可以利用现有的系统构建一个全新的松耦合的异构的分布式系统。</p><p>但，实际使用中，它还是会有很多的缺点，首先就是ESB的本身就很复杂，大大增加了系统的复杂性和可维护性。其次就是由于ESB想要做到所有服务都通过一个通路通信，直接降低了通信速度。</p><p>而在现代的微服务中，往往是一个「富终端、瘦通信」（Smart endpoints and dumb pipes），使用轻量级的通信机制，而每个终端（服务）有自己的处理逻辑，它知道它要找的服务在哪里，不需要在通信的链路上做什么事情。</p><p>然而，ESB是一个历史产物，用今天的眼光看待它，并且将之当做SOA的一个标签是不合理不公平的。</p><p>##通讯协议<br>如今越来越多的工程开始使用RESTful来作为API的设计的基础，但仅仅几年前还有大把的API使用SOAP、WSDL等基于XML的重量级协议的Web Service。</p><p>这点和上文说到的2点其实大同小异，仔细想想，它们都是由于历史原因造成的，同样的，通信协议经过这些年的发展，现在主流的基本上了两种：</p><ol><li>文本协议<br>使用最广泛的多是基于HTTP的RESTful规范</li><li>轻量级二进制协议<br>Thrift、Protobuf，或者任何自定义的轻量级协议<br>###SOAP<br>soap用来描述传递信息的格式</li></ol><p>###WSDL<br>WSDL 用来描述如何访问具体的接口</p><p>###UDDI<br>uddi用来管理，分发，查询webService</p><p>##实例<br>服务端<br><img src="https://www.swapassn.com/picRepo/img/20190730154057.png" alt><br>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * description</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Junwei.Xiong</span></span><br><span class="line"><span class="comment"> * since 2019-07-30 9:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String endpointUrl = <span class="string">"http://localhost:8080/Service/TestServer?wsdl"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title">doRequestWS</span><span class="params">(URL url, String request)</span> </span>&#123;</span><br><span class="line">        HttpURLConnection connection = <span class="keyword">null</span>;</span><br><span class="line">        String rspMsg = <span class="string">""</span>;</span><br><span class="line">        String rspCode = <span class="string">"ERROR"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] requestBuf = (<span class="keyword">byte</span>[]) <span class="keyword">null</span>;</span><br><span class="line">            requestBuf = request.getBytes(<span class="string">"utf-8"</span>);</span><br><span class="line">            connection = (HttpURLConnection) url.openConnection();</span><br><span class="line">            connection.setDoOutput(<span class="keyword">true</span>);</span><br><span class="line">            connection.setDoInput(<span class="keyword">true</span>);</span><br><span class="line">            connection.setRequestMethod(<span class="string">"POST"</span>);</span><br><span class="line">            connection.setUseCaches(<span class="keyword">false</span>);</span><br><span class="line">            connection.setRequestProperty(<span class="string">"Content-Type"</span>, <span class="string">"text/xml"</span>);</span><br><span class="line">            connection.connect();</span><br><span class="line">            DataOutputStream out = <span class="keyword">new</span> DataOutputStream(</span><br><span class="line">                    connection.getOutputStream());</span><br><span class="line">            out.write(requestBuf);</span><br><span class="line">            out.flush();</span><br><span class="line">            out.close();</span><br><span class="line">            <span class="keyword">if</span> (connection.getResponseCode() != <span class="number">200</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"ERROR: "</span> + connection.getResponseMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            InputStream in = connection.getInputStream();</span><br><span class="line">            ByteArrayOutputStream bufOut = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] readBuf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> ret = in.read(readBuf);</span><br><span class="line">                <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                bufOut.write(readBuf, <span class="number">0</span>, ret);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span>[] rspBuf = bufOut.toByteArray();</span><br><span class="line"></span><br><span class="line">            rspMsg = <span class="keyword">new</span> String(rspBuf, <span class="string">"gbk"</span>);</span><br><span class="line">            rspCode = connection.getResponseMessage();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        connection = <span class="keyword">null</span>;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        map.put(<span class="string">"rspCode"</span>, rspCode);</span><br><span class="line">        map.put(<span class="string">"rspMsg"</span>, rspMsg);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">""</span>);</span><br><span class="line">        sb.append(<span class="string">"&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;"</span>);</span><br><span class="line">        sb.append(<span class="string">"&lt;soap:Envelope "</span></span><br><span class="line">                + <span class="string">"xmlns:api='http://service.trembear.com/' "</span></span><br><span class="line">                + <span class="string">"xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' "</span></span><br><span class="line">                + <span class="string">"xmlns:xsd='http://www.w3.org/2001/XMLSchema' "</span></span><br><span class="line">                + <span class="string">"xmlns:soap='http://schemas.xmlsoap.org/soap/envelope/'&gt;"</span>);</span><br><span class="line">        sb.append(<span class="string">"&lt;soap:Body&gt;"</span>);</span><br><span class="line">        sb.append(<span class="string">"&lt;api:helloTest&gt;"</span>);</span><br><span class="line">        sb.append(<span class="string">"&lt;arg0&gt;ls&lt;/arg0&gt;"</span>);</span><br><span class="line">        sb.append(<span class="string">"&lt;/api:helloTest&gt;"</span>);</span><br><span class="line">        sb.append(<span class="string">"&lt;/soap:Body&gt;"</span>);</span><br><span class="line">        sb.append(<span class="string">"&lt;/soap:Envelope&gt;"</span>);</span><br><span class="line">        Map&lt;String, String&gt; map = HttpTest.doRequestWS(</span><br><span class="line">                <span class="keyword">new</span> URL(endpointUrl),</span><br><span class="line">                sb.toString());</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先执行服务端，启动服务，然后执行客户端发起调用。调用的结果如下，可以看到<return>已经有值返回了。<br><img src="https://www.swapassn.com/picRepo/img/20190730154345.png" alt><br>同样的方法在postman中也是能获取到返回值的<br><img src="https://www.swapassn.com/picRepo/img/20190730154645.png" alt></return></p><p>在上面的例子中，很好看出，这个传入的参数（以<code>&lt;soap:Envelope</code>开头的）即是<code>soap</code>。从<code>http://localhost:8080/Service/TestServer?wsdl</code>这个访问浏览器返回的即是<code>wsdl</code>。从wsdl中可以看出这个接口中包含了那些具体的接口，以及需要传入的参数。<br><img src="https://www.swapassn.com/picRepo/img/20190730155029.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于软件系统的架构设计，是一个太多人喜欢讨论的问题，尤其是对软件开发不了解的人士来说，总是被各种各样的概念绕来绕去。从更高的层次，能够很清晰的列出这些众多概念的区别，而身在开发一线的我们更多的是对这些概念有一些感性的、朴素的认识。将之内化到自己的工作中去，才能更好的发挥架构
      
    
    </summary>
    
      <category term="spring" scheme="http://trembear.github.io/categories/spring/"/>
    
    
  </entry>
  
  <entry>
    <title>spring源码阅读2-项目加载配置文件流程</title>
    <link href="http://trembear.github.io/2019/07/02/Spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB2/"/>
    <id>http://trembear.github.io/2019/07/02/Spring源码阅读/spring源码阅读2/</id>
    <published>2019-07-02T09:39:00.000Z</published>
    <updated>2019-10-22T01:33:52.473Z</updated>
    
    <content type="html"><![CDATA[<h2 id="加载流程"><a href="#加载流程" class="headerlink" title="加载流程"></a>加载流程</h2><p>针对以下的例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BeanFactory bf = <span class="keyword">new</span> XmlBeanFactory( <span class="keyword">new</span> ClassPathResource(<span class="string">"spring-config.xml"</span>));</span><br><span class="line">        MyTestBean myTestBean = (MyTestBean) bf.getBean(<span class="string">"myTestBean"</span>);</span><br><span class="line">        Assert.assertEquals(<span class="string">"testName"</span>,myTestBean.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致的流程如下：</p><blockquote><ol><li>设置配置文件位置<ol start="2"><li>读取并且校验配置文件</li><li>将XML文件转为doc文档</li><li>注册doc中的Bean到</li></ol></li></ol></blockquote><p>第一句话可以拆分为两句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Resource resource=<span class="keyword">new</span> ClassPathResource(<span class="string">"spring-config.xml"</span>);</span><br><span class="line">BeanFactory bf = <span class="keyword">new</span> XmlBeanFactory(resource);</span><br></pre></td></tr></table></figure><p>Resource是用于从实际类型的底层资源（例如文件或类路径资源）中抽象的资源描述符的接口。ClassPathResource在加载时，会调用系统的加载classLoader类，加载依赖的class。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathResource</span><span class="params">(String path, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">Assert.notNull(path, <span class="string">"Path must not be null"</span>);</span><br><span class="line">String pathToUse = StringUtils.cleanPath(path);</span><br><span class="line"><span class="keyword">if</span> (pathToUse.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">pathToUse = pathToUse.substring(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.path = pathToUse;</span><br><span class="line"><span class="keyword">this</span>.classLoader = (classLoader != <span class="keyword">null</span> ? classLoader : ClassUtils.getDefaultClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿到resource之后，进入XmlBeanFactory。构造器里有两个主要的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">XmlBeanFactory</span><span class="params">(Resource resource, BeanFactory parentBeanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">//初始化BeanFactory</span></span><br><span class="line"><span class="keyword">super</span>(parentBeanFactory);</span><br><span class="line">    <span class="comment">//加载resource文件</span></span><br><span class="line"><span class="keyword">this</span>.reader.loadBeanDefinitions(resource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟踪<code>super(parentBeanFactory)</code>;跟到最后，是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//忽略给定接口的自动装配，如果A中包含了B，在你注入A的时候，会自动注入B，下面是取消自动注入的代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractAutowireCapableBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">ignoreDependencyInterface(BeanNameAware.class);</span><br><span class="line">ignoreDependencyInterface(BeanFactoryAware.class);</span><br><span class="line">ignoreDependencyInterface(BeanClassLoaderAware.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>this.reader.loadBeanDefinitions(resource);</code> 在调用这个方法的时候，会将<code>resource</code>自动封装为<code>EncodedResource</code>，在这之前，<code>this.reader</code>已经初始化 了,这个初始化为后面的获取实体检验加载器，提供了<code>ResourceLoader</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>后面在<code>XmlBeanDefinitionReader</code>加载代码为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line"><span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br></pre></td></tr></table></figure><p>将文件转为输入流，InputSource不仅包含了InputSource中的内容和编码。继续向下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span>&#123;</span><br><span class="line">    <span class="comment">//读取检验模式（dtd/xsd...）</span></span><br><span class="line">    <span class="keyword">int</span> validationMode = getValidationModeForResource(resource);</span><br><span class="line">    <span class="comment">//将文件流转为Document格式，树状结构</span></span><br><span class="line">    Document doc = <span class="keyword">this</span>.documentLoader.loadDocument(</span><br><span class="line">        inputSource, getEntityResolver(), <span class="keyword">this</span>.errorHandler, validationMode,isNamespaceAware());</span><br><span class="line">    <span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>isNamespaceAware()</code>返回XML解析器是否应该支持XML命名空间。</p><p>在<code>getEntityResolver()</code>中，在初始化<code>reader</code>的时候，<code>ResourceLoader</code>不为空了，执行的是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//entityResolver开始为空，resourceLoader为默认的ClassLoader</span></span><br><span class="line"><span class="keyword">this</span>.entityResolver = <span class="keyword">new</span> ResourceEntityResolver(resourceLoader);</span><br></pre></td></tr></table></figure><p>ResourceEntityResolver类图如下:<br><img src="https://www.swapassn.com/picRepo/img/20190708173233.png" alt><br>ResourceEntityResolver不是spring提供的包，没有继续跟下去了。接着往下看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">private</span> DocumentLoader documentLoader = <span class="keyword">new</span> DefaultDocumentLoader();</span><br><span class="line">...</span><br><span class="line">Document doc = <span class="keyword">this</span>.documentLoader.loadDocument(</span><br><span class="line">inputSource, getEntityResolver(), <span class="keyword">this</span>.errorHandler, validationMode, isNamespaceAware());</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Document <span class="title">loadDocument</span><span class="params">(InputSource inputSource, EntityResolver entityResolver,</span></span></span><br><span class="line"><span class="function"><span class="params">ErrorHandler errorHandler, <span class="keyword">int</span> validationMode, <span class="keyword">boolean</span> namespaceAware)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Using JAXP provider ["</span> + factory.getClass().getName() + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);</span><br><span class="line"><span class="keyword">return</span> builder.parse(inputSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的如何转换可以继续跟，留着以后看，这里应该还包含了从远程下载dtd,xsd约束文件的代码，这个地方先跳过去。回到<code>XmlBeanDefinitionReader.java</code>中的<code>registerBeanDefinitions(doc, resource)</code>中来，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">       <span class="comment">//Environment()从环境中取，与profile字段有关，如果xml中有profile的环境设置，会改变这个值</span></span><br><span class="line">documentReader.setEnvironment(getEnvironment());</span><br><span class="line">       <span class="comment">//原有的BeanDefinitionRegistry 仓库</span></span><br><span class="line"><span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">       <span class="comment">//加载doc</span></span><br><span class="line">documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line"><span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createReaderContext(resource)</code>方法获取在bean读取过程中传递的上下文。</p><p><code>registerBeanDefinitions(doc, createReaderContext(resource))</code>跟踪下去，一直到<code>doRegisterBeanDefinitions</code>方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line"><span class="keyword">if</span> (!getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line"><span class="keyword">this</span>.delegate = createDelegate(<span class="keyword">this</span>.readerContext, root, parent);</span><br><span class="line">preProcessXml(root);</span><br><span class="line">parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">postProcessXml(root);</span><br><span class="line"><span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，<code>preProcessXml</code>和<code>postProcessXml</code>两个方法都是空的，给后来的程序进行扩展，貌似在spring-context中，就有对其扩展的例子</p><h2 id="一些补充"><a href="#一些补充" class="headerlink" title="一些补充"></a>一些补充</h2><p><strong>SAX application</strong>: JAVA 解析 XML 通常有两种方式:DOM 和SAX。DOM（文档对象模型）是W3C标准，提供了标准的解析方式，但其解析效率一直不尽如人意，这是因为DOM解析XML文档时，把所有内容一次性的装载入内存，并构建一个驻留在内存中的树状结构（节点树）。如果需要解析的XML文档过大，或者我们只对该文档中的一部分感兴趣，这样就会引起性能问题。</p><p><strong>EntityResolver</strong>: 如果SAX应用程序实现自定义处理外部实体,则必须实现此接口。Sax 解析xml时需要查找对应的dtd定义。EntityResolver申明了一个如何查询dtd的方法。</p><p>对于不同的验证模式，spring使用了不同的解析器进行解析。 例如在DelegatingEntityResolver中，加载dtd类型的BeansDtdResolver。加载xsd类型的PluggableEntityResolver，两个的解析模式不一样。</p><p><img src="https://www.swapassn.com/picRepo/img/20190709152239.png" alt></p><p>在关于Document是怎么解析这个resolveEntity的具体流程，是在com.sun.org.apache包中实现的，大概的流程如下：</p><p><img src="https://www.swapassn.com/picRepo/img/20190710090528.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;加载流程&quot;&gt;&lt;a href=&quot;#加载流程&quot; class=&quot;headerlink&quot; title=&quot;加载流程&quot;&gt;&lt;/a&gt;加载流程&lt;/h2&gt;&lt;p&gt;针对以下的例子:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
      <category term="spring" scheme="http://trembear.github.io/categories/spring/"/>
    
    
  </entry>
  
  <entry>
    <title>spring源码阅读1-项目的搭建与导入</title>
    <link href="http://trembear.github.io/2019/07/01/Spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB1/"/>
    <id>http://trembear.github.io/2019/07/01/Spring源码阅读/spring源码阅读1/</id>
    <published>2019-07-01T09:39:00.000Z</published>
    <updated>2019-10-22T01:20:39.887Z</updated>
    
    <content type="html"><![CDATA[<h2 id="spring项目下载"><a href="#spring项目下载" class="headerlink" title="spring项目下载"></a>spring项目下载</h2><p>源码对应的书籍为《spring源码深度解析》，由于出书也有一段时间，为了便于对照着学习，所以准备下载的源码为3.2.x版本，下载地址为：<a href="https://github.com/spring-projects/spring-framework/tree/3.2.x。" target="_blank" rel="noopener">https://github.com/spring-projects/spring-framework/tree/3.2.x。</a></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>现在github上的spring项目都是由gradle部署的，所以自己电脑需要提前安装gradle工具，类似于maven，配置好环境后，可以让其更方便的执行。</p><p>下载完成后，可以看到项目根目录中有一个readme.md和import-into-idea.md两个文件。readme文档里面主要是关于一些支持的说明。import-into-idea文档告诉如何在自己的编辑器中部署运行代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">## Steps</span><br><span class="line"></span><br><span class="line">_Within your locally cloned spring-framework working directory:_</span><br><span class="line"></span><br><span class="line">1. Generate IDEA metadata with `./gradlew :spring-oxm:compileTestJava cleanIdea idea`</span><br><span class="line">2. Import into IDEA as usual</span><br><span class="line">3. Set the Project JDK as appropriate</span><br><span class="line">4. Add git support</span><br><span class="line">5. Code away</span><br></pre></td></tr></table></figure><p>按照要求，第一步要执行<code>./gradlew :spring-oxm:compileTestJava cleanIdea idea</code>。在这一步上，第一次耗时比较久，要下载一些依赖。 我在这一步遇到了这个错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FAILURE: Build failed with an exception.</span><br><span class="line"></span><br><span class="line">* Where:</span><br><span class="line">Script &apos;E:\project2019\spring-framework-3.2.13.RELEASE\spring-oxm\oxm.gradle&apos; line: 123</span><br><span class="line"></span><br><span class="line">* What went wrong:</span><br><span class="line">Execution failed for task &apos;:spring-oxm:compileTestJava&apos;.</span><br><span class="line">&gt; JiBXException in JiBX binding compilation</span><br><span class="line"></span><br><span class="line">* Try:</span><br><span class="line">Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.</span><br><span class="line"></span><br><span class="line">BUILD FAILED</span><br></pre></td></tr></table></figure><p><img src="https://www.swapassn.com/picRepo/img/20190701175832.png" alt></p><p>这个错误，错位的位置为oxm.gradle 123行，JiBX没有绑定的错误，结合源码，把这一段注释掉，就没有什么问题了，可以构建成功。</p><p>下一步是导入这个项目，采用gradle的形式进行导入，系统会自动下载其中的依赖，gradle 的模块关系是在根目录下面的settings.gradle中维护的，具体的模块之间的依赖在build.gradle和每个子项目自己的gradle配置文件中有定义。在这里导入会有一些问题。会报如下的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A problem occurred configuring project &apos;:spring-orm-hibernate4&apos;.</span><br></pre></td></tr></table></figure><p>百度了一下，这个问题是由于build.gradle中的<code>merge.into = project(&quot;:spring-****&quot;)</code>引起的，把所有的<code>merge.into</code>都注释了，就不会有问题了。</p><p>刷新gradle依赖后，项目导入成功，没有报错了。</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>在spring根目录下新建一个Gradle的module，专门用来测试自己的数据，setting.gradle文件尾部会自动生成<code>include &#39;mytest&#39;</code>，自己新建的项目中有一个私有的配置build.gradle</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id &apos;java&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group &apos;org.springframework&apos;</span><br><span class="line">version &apos;3.2.13.RELEASE&apos;</span><br><span class="line"></span><br><span class="line">sourceCompatibility = 1.8</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.12&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时，如果要使用其他模块的项目，需要在依赖中导入进来，在这个例子中，需要引入<code>spring-beans</code>和<code>spring-core</code>，修改后的依赖为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile(project(&quot;:spring-beans&quot;))</span><br><span class="line">    compile(project(&quot;:spring-core&quot;))</span><br><span class="line">    testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.12&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立一个spring配置文件spring-config.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">    &lt;bean id=&quot;myTestBean&quot; class=&quot;com.trembear.beans.MyTestBean&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>对应的MyTestBean为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class MyTestBean &#123;</span><br><span class="line"></span><br><span class="line">    private String name = &quot;testName&quot;;</span><br><span class="line"></span><br><span class="line">    public MyTestBean(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MyTestBean() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;MyTestBean&#123;&quot; +</span><br><span class="line">                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后写个Test类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class AppTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        BeanFactory bf = new XmlBeanFactory( new ClassPathResource(&quot;spring-config.xml&quot;));</span><br><span class="line">        MyTestBean myTestBean = (MyTestBean) bf.getBean(&quot;myTestBean&quot;);</span><br><span class="line">        Assert.assertEquals(&quot;testName&quot;,myTestBean.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这段代码，可以正常运行，可以按照书中提示一步步的进行源码阅读了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;spring项目下载&quot;&gt;&lt;a href=&quot;#spring项目下载&quot; class=&quot;headerlink&quot; title=&quot;spring项目下载&quot;&gt;&lt;/a&gt;spring项目下载&lt;/h2&gt;&lt;p&gt;源码对应的书籍为《spring源码深度解析》，由于出书也有一段时间，为了便于
      
    
    </summary>
    
      <category term="spring" scheme="http://trembear.github.io/categories/spring/"/>
    
    
  </entry>
  
  <entry>
    <title>shadowsock服务搭建</title>
    <link href="http://trembear.github.io/2019/07/01/shadowSock%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/"/>
    <id>http://trembear.github.io/2019/07/01/shadowSock服务搭建/</id>
    <published>2019-07-01T04:56:50.000Z</published>
    <updated>2019-10-22T01:20:39.888Z</updated>
    
    <content type="html"><![CDATA[<p>新的linux主机，现在在上面进行shadowsock搭建。</p><h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h2><p>由于登录密码是系统给的，所以顺便改一下密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@172 ~]# passwd root</span><br><span class="line">Changing password for user root.</span><br><span class="line">New password:</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="检查Pip和Python是否安装"><a href="#检查Pip和Python是否安装" class="headerlink" title="检查Pip和Python是否安装"></a>检查Pip和Python是否安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@172 ~]# pip -V</span><br><span class="line">pip 7.1.0 from /usr/lib/python2.6/site-packages (python 2.6)</span><br><span class="line">[root@172 ~]# python -V</span><br><span class="line">Python 2.6.6</span><br><span class="line">[root@172 ~]#</span><br></pre></td></tr></table></figure><p>都安装了，直接进入下一步。</p><h2 id="安装package"><a href="#安装package" class="headerlink" title="安装package"></a>安装package</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure><p>可以看到已经安装了这个。但是pip可以更新一下，这里也可以不更新，应该没有什么问题。这里还是按照提示更新一下。</p><p><img src="https://www.swapassn.com/picRepo/img/20190626184837.png" alt> </p><h2 id="建立配置文件"><a href="#建立配置文件" class="headerlink" title="建立配置文件"></a>建立配置文件</h2><p>选择任意位置建立一个配置文件，这里是在/etc目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/shadowsocks.json</span><br></pre></td></tr></table></figure><p>内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:&quot;服务器 IP 地址&quot;,</span><br><span class="line">    &quot;server_port&quot;:8388,</span><br><span class="line">    &quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;local_port&quot;:1080,</span><br><span class="line">    &quot;password&quot;:&quot;mypassword&quot;,</span><br><span class="line">    &quot;timeout&quot;:300,</span><br><span class="line">    &quot;method&quot;:&quot;aes-256-cfb&quot;,</span><br><span class="line">    &quot;fast_open&quot;: false,</span><br><span class="line">    &quot;workers&quot;: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各个字段的含义如下：</p><p><strong>server</strong>：服务器 IP (IPv4/IPv6)，注意这也将是服务端监听的 IP 地址<br><strong>server_port</strong>：监听的服务器端口<br><strong>local_address</strong>：本地监听的 IP 地址<br><strong>local_port</strong>：本地端端口<br><strong>password</strong>：用来加密的密码<br><strong>timeout</strong>：超时时间（秒）<br><strong>method</strong>：加密方法，可选择 “bf-cfb”, “aes-256-cfb”, “des-cfb”, “rc4″, 等等。默认是一种不安全的加密，推荐用 “aes-256-cfb”<br><strong>fast_open</strong>：true 或 false。如果你的服务器 Linux 内核在3.7+，可以开启 fast_open 以降低延迟。</p><h2 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ssserver -c /etc/shadowsocks.json &gt; /dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><h2 id="检查是否启动"><a href="#检查是否启动" class="headerlink" title="检查是否启动"></a>检查是否启动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep ssserve</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;新的linux主机，现在在上面进行shadowsock搭建。&lt;/p&gt;
&lt;h2 id=&quot;修改密码&quot;&gt;&lt;a href=&quot;#修改密码&quot; class=&quot;headerlink&quot; title=&quot;修改密码&quot;&gt;&lt;/a&gt;修改密码&lt;/h2&gt;&lt;p&gt;由于登录密码是系统给的，所以顺便改一下密码&lt;/p
      
    
    </summary>
    
      <category term="其他" scheme="http://trembear.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
</feed>
